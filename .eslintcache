[{"D:\\React\\demo-upt\\src\\index.tsx":"1","D:\\React\\demo-upt\\src\\App.tsx":"2","D:\\React\\demo-upt\\src\\Containers\\DrawToolComponent.tsx":"3","D:\\React\\demo-upt\\src\\Drawtool\\draw-tool\\DrawTool.ts":"4","D:\\React\\demo-upt\\src\\Drawtool\\draw-tool\\DrawHistory.ts":"5","D:\\React\\demo-upt\\src\\Drawtool\\draw-tool\\Sides.ts":"6","D:\\React\\demo-upt\\src\\Drawtool\\utils\\errors.ts":"7","D:\\React\\demo-upt\\src\\Drawtool\\utils\\escapeJSON.ts":"8","D:\\React\\demo-upt\\src\\Drawtool\\draw-tool\\Side.ts":"9","D:\\React\\demo-upt\\src\\Drawtool\\draw-tool\\Items.ts":"10","D:\\React\\demo-upt\\src\\Drawtool\\draw-tool\\Layers.ts":"11","D:\\React\\demo-upt\\src\\Drawtool\\utils\\clip.ts":"12","D:\\React\\demo-upt\\src\\Drawtool\\draw-tool\\Item.ts":"13"},{"size":219,"mtime":1607690246228,"results":"14","hashOfConfig":"15"},{"size":11204,"mtime":1607781041450,"results":"16","hashOfConfig":"15"},{"size":658,"mtime":1607773580066,"results":"17","hashOfConfig":"15"},{"size":6166,"mtime":1607777276379,"results":"18","hashOfConfig":"15"},{"size":2455,"mtime":1607693220962,"results":"19","hashOfConfig":"15"},{"size":1379,"mtime":1607764439682,"results":"20","hashOfConfig":"15"},{"size":331,"mtime":1607692463886,"results":"21","hashOfConfig":"15"},{"size":202,"mtime":1607763261579,"results":"22","hashOfConfig":"15"},{"size":53633,"mtime":1607778907579,"results":"23","hashOfConfig":"15"},{"size":313,"mtime":1607691416245,"results":"24","hashOfConfig":"15"},{"size":6688,"mtime":1607747328042,"results":"25","hashOfConfig":"15"},{"size":8201,"mtime":1607763587292,"results":"26","hashOfConfig":"15"},{"size":1588,"mtime":1607691418766,"results":"27","hashOfConfig":"15"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},"2oitw0",{"filePath":"31","messages":"32","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"33","messages":"34","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"35","usedDeprecatedRules":"30"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"38","usedDeprecatedRules":"30"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"41","usedDeprecatedRules":"30"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50","usedDeprecatedRules":"30"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"55","usedDeprecatedRules":"30"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"58","usedDeprecatedRules":"30"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},"D:\\React\\demo-upt\\src\\index.tsx",[],["61","62"],"D:\\React\\demo-upt\\src\\App.tsx",["63","64","65","66"],"D:\\React\\demo-upt\\src\\Containers\\DrawToolComponent.tsx",["67","68"],"import { Component, ReactNode } from \"react\";\r\nimport DrawTool from \"../Drawtool/draw-tool/DrawTool\";\r\n\r\ninterface Props {\r\n    colors:any\r\n }\r\n\r\ninterface State {\r\n    node: ReactNode\r\n};\r\n\r\nclass DrawToolComponent extends Component<Props, State>{\r\n    state: State = {\r\n        node: null\r\n    };\r\n    constructor(props: Props) {\r\n        super(props)\r\n    }\r\n\r\n    componentDidMount() {\r\n        DrawTool.initialize(this.state.node as HTMLElement, {});\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className=\"draw-tool\" ref={(node) => { this.state.node = node; return node }} />\r\n        );\r\n    }\r\n\r\n}\r\n\r\nexport default DrawToolComponent;","D:\\React\\demo-upt\\src\\Drawtool\\draw-tool\\DrawTool.ts",["69","70","71","72"],"import errors from \"../utils/errors\";\r\nimport escapeJSON from \"../utils/escapeJSON\";\r\nimport DrawHistory from \"./DrawHistory\";\r\nimport Side from \"./Side\";\r\nimport Sides from \"./Sides\";\r\n\r\nlet DrawTool = {\r\n    editable: false,\r\n    container: {\r\n        target: document.body,\r\n        size: {\r\n            width: 0,\r\n            height: 0\r\n        }\r\n    },\r\n    modeSetup: {\r\n        NOMAL: -1,\r\n        EMBROIDER: 1,\r\n        LASER: 3,\r\n        MASK_LASER: 4,\r\n        TAP_RIBBON: 5, //Type1(white, black, red, blue )   ?Tape Editor\r\n        TAP_RIBBON_2EDIT: 6, //Type2(black, red, blue, gold, silver) ?Ribbon Editor\r\n        DRAW3D: 20\r\n    },\r\n    uploadImageState: [],\r\n    gridStep: 10,\r\n    grid: {\r\n        color: 'rgba(150, 150, 150, 0.1)',\r\n        strokeWidth: 1\r\n    },\r\n    border: {\r\n        color: 'rgba(100,200,200,1)',\r\n        strokeWidth: 1,\r\n        backgroundColor: 'rgba(150, 150, 150, 0.1)',\r\n        strokeDashArray: [0, 0],\r\n    },\r\n    newColorPicked: null,\r\n\r\n    _callbacks: {} as any,\r\n\r\n    sides: new Sides(),\r\n    history: new DrawHistory(),\r\n    _evented: true,\r\n\r\n    __data: {} as any,\r\n    modeSpecialDrawEnable: -1,\r\n    is_embroidery: false,\r\n    embroider_able: false,\r\n    capacity_uploadingAllImage: 0,\r\n    _originalJson: {},\r\n\r\n    _designBorders: [] as any[],\r\n    _embroideryPaths: [],\r\n    is_choosing: false,\r\n\r\n    is_nail: false,\r\n\r\n    is_mobile: false,\r\n    is_data: [],\r\n    is_sp_product: false,\r\n    is_area_embroider: false,\r\n    fonts: null,\r\n    rasterizedText: null,\r\n    modeToolDraw: null,\r\n    //func\r\n    initialize(target: HTMLElement, size: any) {\r\n        if (!(target instanceof HTMLElement)) {\r\n            throw (new Error(JSON.stringify({ error: errors.HTMLElementUndefined })));\r\n        }\r\n        console.log(target);\r\n\r\n        // let _target = window.hasOwnProperty('jQuery') && target instanceof jQuery ? target[0] : target;\r\n        let _target = target;\r\n\r\n        let _size = size || {};\r\n\r\n        this.container = {\r\n            target: _target,\r\n            size: _size\r\n        };\r\n\r\n        this.container.target.textContent = '';\r\n        this.container.target.style.position = 'relative';\r\n\r\n        // this.sides = new Sides();\r\n\r\n        this.history = new DrawHistory();\r\n    },\r\n\r\n    setLayerSetup(val = 0) {\r\n        this.modeSpecialDrawEnable = val;\r\n        if (this.modeSpecialDrawEnable < 1) {\r\n            this.sides.selected._selected_path_index = -1;\r\n            this.is_embroidery = false;\r\n        } else {\r\n            this.sides.selected._selected_path_index = this.modeSpecialDrawEnable;\r\n            //if(this.modeSpecialDrawEnable==1) this.is_embroidery = true;\r\n        }\r\n        this.sides._collection.map((side: Side) => {\r\n            side.setSelectableForDesign();\r\n        });\r\n        this.sides.selected.FabricCanvas.renderAll();\r\n    },\r\n\r\n\r\n    importJSON(json: String, initialZoom?: Number, proportions?: Number | 0.5) {\r\n        this._originalJson = json;\r\n        let oldSideSizes: any = {};\r\n\r\n        // Array.prototype.forEach.call(this.sides._collection, (side: Side) => {\r\n        //     if (side.layers.list.length)\r\n        //         oldSideSizes[side.id] = side.getOccupiedAreaSize();\r\n        // });\r\n\r\n        if (this.sides._collection.length) {\r\n            this.sides.empty();\r\n            this.history.history = {};\r\n        }\r\n        let that = this\r\n\r\n        let data = JSON.parse(escapeJSON(json));\r\n        DrawTool.is_data = JSON.parse(escapeJSON(json));\r\n        let promises = data.map((side: Side) => {\r\n            let _side = this.sides.addSide(side.id);\r\n            let imageUrl = side.imageUrl;\r\n\r\n            if (imageUrl.indexOf('http') === 0)\r\n                imageUrl += '?_';\r\n\r\n            var border = { sideId: side.id, border: [side.border.cm, side.border.pixel] };\r\n            this._designBorders.push(border);\r\n\r\n            return _side.setImage(imageUrl, side.size.cm, proportions, side.border.cm);\r\n        });\r\n\r\n        var spProductObj = data.find((dt: any) => {\r\n            return dt.id === '1';\r\n        });\r\n\r\n        if (spProductObj.border.cm.width === 120) {\r\n            this.is_sp_product = true;\r\n        } else {\r\n            this.is_sp_product = false;\r\n        }\r\n\r\n        return new Promise<any>((resolve, reject) => {\r\n\r\n            Promise.all(promises).then(values => {\r\n                values.map((d: any, index) => {\r\n                    let _side = that.sides.getSide(d.side.id);\r\n\r\n                    _side.defaultWorkspaceSize = data[index].border.pixel;\r\n\r\n                    // _side.setBorder(data[index].border);\r\n\r\n                    if (initialZoom) {\r\n                        _side.zoomToVal(initialZoom);\r\n                    }\r\n                    if ((DrawTool.modeToolDraw == DrawTool.modeSetup.TAP_RIBBON) || (DrawTool.modeToolDraw == DrawTool.modeSetup.TAP_RIBBON_2EDIT)) {\r\n                        _side.zoomToVal(1.6);\r\n                    }\r\n\r\n                    setTimeout(() => {\r\n                        if (this.__data[_side.id]) {\r\n                            if (oldSideSizes[_side.id] && !this.is_choosing) {\r\n                                _side.fromJSON(this.__data[_side.id], () => { }, false, oldSideSizes[_side.id]);\r\n                                this.is_choosing = false;\r\n                            }\r\n                            else\r\n                                _side.fromJSON(this.__data[_side.id]);\r\n                        }\r\n\r\n                        _side.FabricCanvas.renderAll.bind(_side.FabricCanvas);\r\n                    });\r\n                });\r\n\r\n                resolve(null);\r\n            });\r\n        });\r\n    },\r\n\r\n\r\n    trigger(event: String, data: Object) {\r\n\r\n        if (!this._evented) {\r\n            return false;\r\n        }\r\n\r\n        // if (event === 'history:update') {\r\n        //     this.history.pushState(data.side.id);\r\n        //     this.sides.getSide(data.side.id).layers.update();\r\n        // }\r\n\r\n        // if (typeof this._callbacks[event] !== 'undefined') {\r\n        //     this._callbacks[event].forEach(cb => cb(JSON.stringify(data)));\r\n        // }\r\n    },\r\n}\r\n\r\nexport default DrawTool;","D:\\React\\demo-upt\\src\\Drawtool\\draw-tool\\DrawHistory.ts",["73"],"import DrawTool from './DrawTool';\r\n\r\nclass DrawHistory {\r\n    history: any = {}\r\n    constructor() {\r\n        this.history = {};\r\n    }\r\n\r\n    resetHistory() {\r\n        this.history = {};\r\n    }\r\n\r\n    // pushState(id: string) {\r\n\r\n    //     if (typeof this.history[id] === 'undefined') {\r\n    //         this.history[id] = {\r\n    //             collection: [],\r\n    //             currentIndex: 0\r\n    //         };\r\n    //     }\r\n\r\n    //     let side = DrawTool.sides.getSide(id);\r\n    //     let state = JSON.stringify(side.FabricCanvas.toObject(['brush', 'editable', 'vertical', 'color', 'typeSVG', 'pathIndex', 'fileContent', 'fileContentURL', 'typePaths', 'lastBorder']));\r\n    //     this.history[id].collection = this.history[id].collection.slice(0, this.history[id].currentIndex + 1);\r\n    //     this.history[id].collection.push(state);\r\n    //     this.history[id].currentIndex = this.history[id].collection.length - 1;\r\n    // }\r\n\r\n    // undo(id) {\r\n    //     let side = DrawTool.sides.getSide(id);\r\n\r\n    //     if (!this.history[id].collection.length) {\r\n    //         this.history[id].currentIndex = 0;\r\n    //         return false;\r\n    //     }\r\n\r\n    //     if (this.history[id].currentIndex <= 0) {\r\n    //         this.history[id].currentIndex = 0;\r\n    //         return false;\r\n    //     }\r\n\r\n    //     let state = this.history[id].collection[this.history[id].currentIndex - 1];\r\n    //     this.history[id].currentIndex -= 1;\r\n\r\n    //     side.loadFromJSON(state, side);\r\n\r\n    //     DrawTool.trigger('history:undo', { currentIndex: this.history[id].currentIndex, next: this.history[id].currentIndex > 0 });\r\n    //     side.setSelectableForDesign();\r\n    // }\r\n\r\n    // redo(id) {\r\n\r\n    //     let side = DrawTool.sides.getSide(id);\r\n\r\n    //     if (!this.history[id].collection.length) {\r\n    //         return false;\r\n    //     }\r\n\r\n    //     if (this.history[id].currentIndex >= this.history[id].collection.length - 1) {\r\n    //         return false;\r\n    //     }\r\n\r\n    //     let state = this.history[id].collection[this.history[id].currentIndex + 1];\r\n    //     this.history[id].currentIndex += 1;\r\n\r\n    //     side.loadFromJSON(state, side);\r\n\r\n    //     DrawTool.trigger('history:redo', { currentIndex: this.history[id].currentIndex, next: this.history[id].currentIndex < this.history[id].collection.length - 1 });\r\n    //     side.setSelectableForDesign();\r\n    // }\r\n\r\n}\r\n\r\nexport default DrawHistory;\r\n","D:\\React\\demo-upt\\src\\Drawtool\\draw-tool\\Sides.ts",[],"D:\\React\\demo-upt\\src\\Drawtool\\utils\\errors.ts",[],"D:\\React\\demo-upt\\src\\Drawtool\\utils\\escapeJSON.ts",[],"D:\\React\\demo-upt\\src\\Drawtool\\draw-tool\\Side.ts",["74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","89","90","91"],"import DrawTool from \"./DrawTool\";\r\nimport Items from \"./Items\";\r\nimport fabric from 'fabric'\r\nimport Layers from \"./Layers\";\r\nimport escapeJSON from \"../utils/escapeJSON\";\r\nimport clip from \"../utils/clip\";\r\nclass Side {\r\n    id: string\r\n    container: any\r\n    canvas: HTMLCanvasElement\r\n    padding: any\r\n    isZoom: any\r\n    currentPathPosision: any\r\n    _selected_path_index: any\r\n    _changeBorder: any\r\n    border_special: any\r\n    start_boder: any\r\n    nameSide: any\r\n    _panning: any\r\n    is_empty: any\r\n    number_embroider: any\r\n    number_special_draw: any\r\n    number_embroider_sp: any\r\n    number_draw: any\r\n    number_print_draw: any\r\n    overlay: any\r\n    _zoom_zone: any\r\n    imageUrl: any\r\n    overlayImage: any\r\n    _selected_path_indexis_nail: any\r\n    items: any\r\n\r\n    center: any\r\n    FabricCanvas: any\r\n\r\n    FabricBorder: any\r\n    layers: Layers\r\n    border: any\r\n    size: any\r\n    bgOffset: any\r\n    backdrop: any\r\n    _pan_x0: any\r\n    _pan_y0: any\r\n    defaultWorkspaceSize: any\r\n    cmSize: any\r\n    bgProportions: any\r\n\r\n    constructor(id: string) {\r\n        let that = this;\r\n        this.id = id;\r\n\r\n        this.container = document.createElement('div');\r\n\r\n        this.canvas = document.createElement('canvas');\r\n\r\n        this.padding = 10;\r\n\r\n        this.isZoom = false;\r\n\r\n        this._selected_path_index = 1;\r\n\r\n        this._changeBorder = false;\r\n\r\n        this.currentPathPosision = null;\r\n        this.border_special = null;\r\n        this.start_boder = {};\r\n        this.nameSide = '';\r\n\r\n        this._panning = false;\r\n\r\n        this.is_empty = true;\r\n        this.number_embroider = 0;\r\n        this.number_special_draw = 0;\r\n        this.number_embroider_sp = {};\r\n        this.number_draw = 0;\r\n        this.number_print_draw = 0;\r\n\r\n        this.overlay = false;\r\n\r\n        this._zoom_zone = false;\r\n\r\n        this.imageUrl = null;\r\n\r\n        this.overlayImage = null;\r\n        this._selected_path_index = -1;\r\n        this._selected_path_indexis_nail = 1;\r\n\r\n        this.container.width = DrawTool.container.size.width || DrawTool.container.target.clientWidth;\r\n        this.container.height = DrawTool.container.size.height || DrawTool.container.target.clientHeight;\r\n        this.container.style.position = 'absolute';\r\n        this.container.style.top = '0';\r\n        this.container.style.left = '0';\r\n\r\n        this.canvas.width = DrawTool.container.size.width || DrawTool.container.target.clientWidth;\r\n        this.canvas.height = DrawTool.container.size.height || DrawTool.container.target.clientHeight;\r\n\r\n        this.container.appendChild(this.canvas);\r\n        console.log( DrawTool.container.target);\r\n        DrawTool.container.target.appendChild(this.container);\r\n\r\n\r\n        this._initFabric();\r\n        this._initEvents();\r\n\r\n        this.items = new Items(this);\r\n\r\n        this.layers = new Layers(this);\r\n\r\n        // this.currentBrush = 'PencilBrush';\r\n\r\n        // this.colorPicker = new colorPicker(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    // * Set side image\r\n    // * @param {String} url\r\n    // * @param size {Object} size\r\n    // * @param size.width {Number} Width of image in centimeters\r\n    // * @param size.height {Number} Height of image in centimeters\r\n    // * @param proportions {Number}\r\n    // * @param borderSize {Object}\r\n    // * @return {Promise}\r\n    setImage(url: String, size?: any, proportions: any = 1, borderSize?: any) {\r\n\r\n        this.size = size;\r\n\r\n        this.imageUrl = url;\r\n\r\n        let center = this.FabricCanvas.getCenter();\r\n\r\n        return new Promise((resolve, reject) => {\r\n\r\n            this.FabricCanvas.setBackgroundColor('#ffffff');\r\n\r\n            this.FabricCanvas.setBackgroundImage(url, (img: fabric.fabric.Image) => {\r\n\r\n                this.backdrop = this.FabricCanvas.backgroundImage;\r\n\r\n                this.backdrop.excludeFromExport = true;\r\n\r\n                let canvasAspectRatio = this.canvas.width / this.canvas.height;\r\n                let borderAspectRatio = borderSize.width / borderSize.height;\r\n\r\n                if (canvasAspectRatio < borderAspectRatio) {\r\n                    let canvasProportions = this.FabricCanvas.width / this.size.width;\r\n                    this.bgProportions = (this.FabricCanvas.width * proportions) / (borderSize.width * canvasProportions);\r\n\r\n                    this.backdrop.scaleToWidth(this.size.width * canvasProportions * this.bgProportions);\r\n                } else {\r\n                    let canvasProportions = this.FabricCanvas.height / this.size.height;\r\n                    this.bgProportions = (this.FabricCanvas.height * proportions) / (borderSize.height * canvasProportions);\r\n\r\n                    this.backdrop.scaleToHeight(this.size.height * canvasProportions * this.bgProportions);\r\n                }\r\n\r\n                this._setOffset(borderSize);\r\n\r\n                this.FabricCanvas.backgroundImage.top -= this.bgOffset.top;\r\n                this.FabricCanvas.backgroundImage.left -= this.bgOffset.left;\r\n\r\n                this.cmSize = this._calculateSize();\r\n\r\n                this.FabricCanvas.renderAll();\r\n\r\n                DrawTool.trigger('backdrop:loaded', { side: { id: this.id } });\r\n\r\n                // DrawTool.history.pushState(this.id);\r\n                resolve({ side: { id: this.id } });\r\n            }, {\r\n                top: center.top,\r\n                left: center.left,\r\n                originX: 'center',\r\n                originY: 'center',\r\n                opacity: 1,\r\n                crossOrigin: 'anonymous'\r\n            });\r\n        });\r\n    }\r\n\r\n    _setOffset(borderSize: any) {\r\n        this.bgOffset = {\r\n            left: 0,\r\n            top: 0\r\n        };\r\n\r\n        this.bgOffset.left = (borderSize.left - ((this.size.width - borderSize.width) / 2)) * this.backdrop.scaleX;\r\n        this.bgOffset.top = (borderSize.top - ((this.size.height - borderSize.height) / 2)) * this.backdrop.scaleY;\r\n\r\n        return true;\r\n    }\r\n\r\n    _calculateSize() {\r\n        this.cmSize = {\r\n            width: ((this.backdrop.width * this.backdrop.scaleX) / this.size.width),\r\n            height: ((this.backdrop.height * this.backdrop.scaleY) / this.size.height)\r\n        };\r\n        return this.cmSize;\r\n    }\r\n\r\n    zoomToVal(val: Number) {\r\n        let center = this.FabricBorder.getCenterPoint();\r\n        this.FabricCanvas.zoomToPoint(center, val);\r\n        return this;\r\n    }\r\n\r\n\r\n\r\n    _initFabric() {\r\n\r\n        this.FabricCanvas = new fabric.fabric.Canvas(this.canvas, {\r\n            selection: false,\r\n            enableRetinaScaling: true,\r\n            preserveObjectStacking: true\r\n        });\r\n\r\n        // this.FabricCanvas.toJSON('objects.brush');\r\n\r\n        this.FabricCanvas.wrapperEl.style.display = 'none';\r\n\r\n        this.FabricCanvas.upperCanvasEl.style['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\r\n        this.FabricCanvas.lowerCanvasEl.style['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\r\n    }\r\n\r\n\r\n    _initEvents() {\r\n        this.FabricCanvas.on({\r\n            'after:render': (e: any) => {\r\n                DrawTool.trigger('after:render', {});\r\n            },\r\n            'object:added': (e: any) => {\r\n                if (e.target.id != \"FabricBorder\") {\r\n                    this.is_empty = false;\r\n                }\r\n                if (!e.target.excludeFromExport) {\r\n                    DrawTool.trigger('object:added', { side: { id: this.id }, item: e.target.toObject(['brush', 'editable', 'vertical', 'uuid']).uuid });\r\n                }\r\n            },\r\n            'selection:cleared': (e: any) => {\r\n                if (this.items.selected.item) {\r\n                    this.items.selected.item.selected = false;\r\n                }\r\n                this.items.selected.item = null;\r\n                DrawTool.trigger('selection:cleared', e);\r\n            },\r\n            'selection:created': (e: any) => {\r\n                DrawTool.trigger('selection:created', e);\r\n            },\r\n            'object:selected': (e: any) => {\r\n                if (e.target.id === 'FabricBorder') {\r\n                    e.target.setCoords();\r\n                    this.center = this.FabricBorder.getCenterPoint();\r\n                }\r\n                this.items.selected.item = e.target;\r\n                this.items.selected.item.selected = true;\r\n                DrawTool.trigger('object:selected', { side: { id: this.id }, isWorkSpaceBorder: e.target.id === 'FabricBorder' });\r\n            },\r\n            //   'object:modified': (e) => {\r\n            //     this.checkEmpty()\r\n            //     if (e.target.id === 'FabricBorder') {\r\n            //       e.target.setCoords();\r\n            //       this.center = this.FabricBorder.getCenterPoint();\r\n            //       this.initWorkspaceGrid();\r\n            //       this.initWorkspaceRuler();\r\n            //     }\r\n            //     DrawTool.trigger('object:modified', {side: {id: this.id}, isWorkSpaceBorder: e.target.id === 'FabricBorder', item: e.target.toObject(['brush', 'editable', 'vertical', 'uuid']).uuid});\r\n            //     if(!e.target.excludeFromExport){\r\n            //       DrawTool.trigger('history:update', {side: {id: this.id}, isWorkSpaceBorder: false});\r\n            //     }\r\n\r\n            //   },\r\n            //   'object:removed': (e) => {\r\n            //     this.checkEmpty()\r\n            //     if(e.target && !e.target.excludeFromExport){\r\n            //       DrawTool.trigger('object:removed', {side: {id: this.id}, item: e.target.toObject(['brush', 'editable', 'vertical', 'uuid']).uuid});\r\n            //       DrawTool.trigger('history:update', {side: {id: this.id}});\r\n            //     }\r\n            //   },\r\n            //   'editing:exited': () => {\r\n            //     DrawTool.trigger('editing:exited', {side: {id: this.id}});\r\n            //   },\r\n            //   'editing:entered': () => {\r\n            //     DrawTool.trigger('editing:entered', {side: {id: this.id}});\r\n            //   },\r\n            //   'mouse:up': (e) => {\r\n            //     this._panningDown = false;\r\n\r\n            //     if(DrawTool.is_nail && this._zoom_zone){\r\n            //       var touches = e.e.touches && e.e.touches.length ? e.e.touches : [e.e];\r\n            //       var evt = (e.e.changedTouches && e.e.changedTouches[0]) || touches[0];\r\n\r\n            //       let x = evt.layerX || evt.pageX || 0;\r\n            //       let y = evt.layerY || evt.pageY || 0;\r\n\r\n            //       if(DrawTool.is_mobile){\r\n            //         y -= 65;\r\n            //         this._pan_y0 -= 65;\r\n            //       }\r\n\r\n            //       let centerX = (x + this._pan_x0) / 2;\r\n            //       let centerY = (y + this._pan_y0) / 2;\r\n\r\n            //       let min = {};\r\n            //       let minPathIndex = 0;\r\n            //       let minDistance = 1000000;\r\n            //       let zoom = this.FabricCanvas.getZoom();\r\n\r\n            //       this.FabricBorder._objects.map((o,index)=>{\r\n            //         if(index !== 0){\r\n            //           let aX = this.FabricBorder.oCoords.tl.x + (o.aCoords.tl.x + o.aCoords.tr.x) * zoom / 2;\r\n            //           let aY = this.FabricBorder.oCoords.tl.y + (o.aCoords.tl.y + o.aCoords.bl.y) * zoom / 2;\r\n            //           let currentDistance = Math.sqrt(Math.pow(aX - centerX, 2) + Math.pow(aY - centerY, 2));\r\n            //           if(currentDistance < minDistance){\r\n            //             minDistance = currentDistance;\r\n            //             minPathIndex = index;\r\n            //             min = {x: aX, y: aY};\r\n            //           }\r\n            //         }\r\n            //       });\r\n\r\n            //       let pointMinX = Math.min(x, this._pan_x0);\r\n            //       let pointMinY = Math.min(y, this._pan_y0);\r\n            //       let pointMaxX = Math.max(x, this._pan_x0);\r\n            //       let pointMaxY = Math.max(y, this._pan_y0);\r\n\r\n            //       let minPath = this.FabricBorder._objects[minPathIndex];\r\n            //       let pathMinX = this.FabricBorder.oCoords.tl.x + minPath.aCoords.tl.x * zoom;\r\n            //       let pathMinY = this.FabricBorder.oCoords.tl.y + minPath.aCoords.tl.y * zoom;\r\n            //       let pathMaxX = this.FabricBorder.oCoords.tl.x + minPath.aCoords.tr.x * zoom;\r\n            //       let pathMaxY = this.FabricBorder.oCoords.tl.y + minPath.aCoords.bl.y * zoom;\r\n\r\n            //       if(pointMinX <= pathMinX &&\r\n            //          pointMinY <= pathMinY &&\r\n            //          pointMaxX >= pathMaxX &&\r\n            //          pointMaxY >= pathMaxY){\r\n            //           this._selected_path_index = minPathIndex;\r\n            //           this.FabricCanvas.relativePan({ x: this.center.x - min.x, y:this.center.y - min.y});\r\n            //           this.FabricCanvas.renderAll();\r\n\r\n            //           let center = new fabric.Point(this.FabricCanvas.getWidth() / 2, this.FabricCanvas.getHeight() / 2);\r\n            //           this.FabricCanvas.zoomToPoint(center, 3);\r\n            //           this.FabricCanvas.renderAll();\r\n            //          }\r\n            //     }\r\n            //   },\r\n            //   'mouse:down': (e) => {\r\n            //     this._panningDown = true;\r\n\r\n            //     var touches = e.e.touches && e.e.touches.length ? e.e.touches : [e.e];\r\n            //     var evt = (e.e.changedTouches && e.e.changedTouches[0]) || touches[0];\r\n\r\n            //     this._pan_x0 = evt.layerX || evt.pageX || 0;\r\n            //     this._pan_y0 = evt.layerY || evt.pageY || 0;\r\n\r\n            //     if(this.colorPicker.active){\r\n            //       this.colorPicker.move(e);\r\n            //       DrawTool.trigger('colorpicker:update', this.colorPicker.color);\r\n            //     }\r\n\r\n            //   },\r\n            //   'mouse:move': (e) => {\r\n\r\n            //   //  DrawTool.trigger('mouse:move');\r\n\r\n            //     if (!!(this._panning && this._panningDown && e && e.e)) {\r\n\r\n            //       var touches = e.e.touches && e.e.touches.length ? e.e.touches : [e.e];\r\n            //       var evt = (e.e.changedTouches && e.e.changedTouches[0]) || touches[0];\r\n\r\n            //       let x = evt.layerX || evt.pageX || 0;\r\n            //       let y = evt.layerY || evt.pageY || 0;\r\n\r\n            //       this.FabricCanvas.relativePan({ x: x - this._pan_x0, y: y - this._pan_y0});\r\n            //       this._pan_x0 = x;\r\n            //       this._pan_y0 = y;\r\n            //     }\r\n            //     if(this.colorPicker.active){\r\n            //       this.colorPicker.move(e); \r\n            //     }\r\n            //   },\r\n            //   'object:moving': (e) => {\r\n            //     if(DrawTool.is_embroidery){\r\n            //                 if (!!(e && e.e&&e.target)) {\r\n            //                       var angle=0;\r\n            //                       if(e.target.angle) angle=e.target.angle;\r\n            //                       var left1=this.FabricBorder._originalLeft;\r\n            //                       var left2=left1+this.FabricBorder.width;\r\n            //                       var widthDiv2 = e.target.width / 2 * e.target.scaleX*Math.abs(Math.cos(angle*Math.PI/180))+\r\n            //                       e.target.height / 2 * e.target.scaleY*Math.abs(Math.sin(angle*Math.PI/180));\r\n            //                       if((e.target.left+ widthDiv2)>left2){\r\n            //                         e.target.left=left2-widthDiv2;\r\n            //                       }\r\n            //                       else\r\n            //                       if((e.target.left- widthDiv2)<left1){\r\n            //                         e.target.left=left1+widthDiv2;\r\n            //                       }\r\n            //                 }\r\n            //             } else {\r\n            //       if (!!(e && e.e && e.target)) {\r\n            //         if (Math.abs(e.target.left-this.center.x)<5){\r\n            //           e.target.left = this.center.x;\r\n            //           e.target.actionMoveX=true;\r\n            //         }\r\n            //         else\r\n            //         {\r\n            //           e.target.actionMoveX=false;\r\n            //         }\r\n\r\n            //         if (Math.abs(e.target.top-this.center.y)<5){\r\n            //           e.target.top = this.center.y;\r\n            //           e.target.actionMoveY=true;\r\n            //         }\r\n            //         else\r\n            //         {\r\n            //           e.target.actionMoveY=false;\r\n            //         }\r\n            //       }\r\n            //     }\r\n            //   },\r\n            //   'object:scaling': (e) => {\r\n            //     if(!!e.e.touches && e.e.touches.length >1) {\r\n            //       return false\r\n            //     } else {\r\n            //       let obj = e.target;\r\n            //       if (DrawTool.is_embroidery) {\r\n            //         var angle=0;\r\n            //         if(e.target.angle) angle=e.target.angle;\r\n            //         var left1 = this.FabricBorder._originalLeft;\r\n            //         var left2 = left1 + this.FabricBorder.width;\r\n            //         var widthDiv2 = e.target.width  * e.target.scaleX*Math.abs(Math.cos(angle*Math.PI/180))+e.target.height / 2 * e.target.scaleY*Math.abs(Math.sin(angle*Math.PI/180));\r\n            //         if(widthDiv2>this.FabricBorder.width){\r\n            //           widthDiv2=this.FabricBorder.width/2;\r\n            //           e.target.left = left2 - widthDiv2;\r\n            //           e.target.scaleToWidth(this.FabricBorder.width);\r\n            //         }\r\n            //         else\r\n            //         {\r\n            //           widthDiv2=widthDiv2/2;\r\n            //           if (e.target.left + widthDiv2 > left2) {\r\n            //             e.target.left = left2 - widthDiv2;\r\n            //           } else if (e.target.left - widthDiv2 < left1) {\r\n            //             e.target.left = left1 + widthDiv2;\r\n            //           }\t\r\n            //         }\t\t\t\t\r\n            //       }\r\n            //       if (obj.type.includes('path') || obj.type.includes('i-text') || obj.type.includes('curvedText')) {\r\n            //         return false;\r\n            //       }\r\n\r\n            //       let w = obj.width * obj.scaleX;\r\n            //       let h = obj.height * obj.scaleY;\r\n            //       let s = obj.strokeWidth;\r\n\r\n            //       obj.set({\r\n            //         'height'     : h,\r\n            //         'width'      : w,\r\n            //         'scaleX'     : 1,\r\n            //         'scaleY'     : 1  \r\n            //       });\r\n            //     }\r\n            //   },\r\n            //   'object:rotating': function objectRotate(e) {\r\n            //     DrawTool.trigger('object:rotating');\r\n            //   },\r\n        });\r\n    }\r\n\r\n    saveBoder(start: any, special = null) {\r\n        this.border_special = special;\r\n        this.start_boder = start;\r\n    }\r\n\r\n    async setOverlayBorder(overlayImage: any, reset = false) {\r\n        if (reset) {\r\n            if (this.overlayImage !== null) {\r\n                overlayImage = this.overlayImage;\r\n            }\r\n            else {\r\n                return;\r\n            }\r\n        }\r\n        else {\r\n            this.overlayImage = overlayImage;\r\n        }\r\n        setTimeout(() => {\r\n            let center = this.FabricCanvas.getCenter();\r\n            this.FabricCanvas.setOverlayImage(overlayImage, () => {\r\n                this.FabricCanvas.overlayImage.scaleX = this.backdrop.scaleX;\r\n                this.FabricCanvas.overlayImage.scaleY = this.backdrop.scaleY;\r\n                this.FabricCanvas.overlayImage.originX = 'center';\r\n                this.FabricCanvas.overlayImage.originY = 'center';\r\n                this.FabricCanvas.overlayImage.top = center.top - this.bgOffset.top;\r\n                this.FabricCanvas.overlayImage.left = center.left - this.bgOffset.left;\r\n                this.FabricCanvas.renderAll();\r\n            });\r\n            this.FabricCanvas.forEachObject((item: any) => {\r\n                item.setClipTo(null);\r\n            })\r\n            this.FabricCanvas.renderAll();\r\n        }, 500);\r\n    }\r\n\r\n\r\n    setSelectableForDesign() {\r\n        let that1 = this;\r\n        if (this._panning) {\r\n            this.items._collection.forEach((object: any) => object.selectable = false);\r\n        } else {\r\n            this.items._collection.forEach((object: any) => {\r\n                if (DrawTool.is_embroidery) {\r\n                    if (object.pathIndex) {\r\n                        //|| DrawTool.is_area_embroider !== object.areaEmbroider \r\n                        if (object.pathIndex === -1) {\r\n                            object.selectable = false;\r\n                            object.evented = false;\r\n                        }\r\n                        else {\r\n                            if (object.pathIndex == 1) {\r\n                                if (!!!object.areaEmbroider) {\r\n                                    let border = DrawTool.sides.selected.FabricBorder;\r\n                                    let border_coords = that1.getValuefromHash(border.aCoords);\r\n                                    if (that1.doPolygonsIntersect(border_coords, that1.getValuefromHash(object.aCoords)) && object.id != \"FabricBorder\") {\r\n                                        object.selectable = true;\r\n                                        object.evented = true;\r\n                                    }\r\n                                    else {\r\n                                        object.selectable = false;\r\n                                        object.evented = false;\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    if (DrawTool.is_area_embroider !== object.areaEmbroider) {\r\n                                        object.selectable = false;\r\n                                        object.evented = false;\r\n                                    }\r\n                                    else {\r\n                                        object.selectable = true;\r\n                                        object.evented = true;\r\n                                    }\r\n                                }\r\n                            }\r\n                            else {\r\n                                object.selectable = false;\r\n                                object.evented = false;\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        object.selectable = false;\r\n                        object.evented = false;\r\n                    }\r\n                } else {\r\n                    if (DrawTool.modeSpecialDrawEnable > 1) {\r\n                        if (object.pathIndex === DrawTool.modeSpecialDrawEnable) {\r\n                            object.selectable = true;\r\n                            object.evented = true;\r\n                        }\r\n                        else {\r\n                            object.selectable = false;\r\n                            object.evented = false;\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (object.pathIndex > 0) {\r\n                            object.selectable = false;\r\n                            object.evented = false;\r\n                        }\r\n                        else {\r\n                            object.selectable = true;\r\n                            object.evented = true;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n *\r\n * @param {String} json\r\n */\r\n    fromJSON(json: String, callback?: any, firstOfHistory = false, sizeOldWorkArea = false) {\r\n        let data = JSON.parse(escapeJSON(json));\r\n        let filters = {} as any;\r\n        let proportionsOnOld = 1;\r\n        Array.prototype.forEach.call(data.canvas.objects, function (item, i) {\r\n            if (typeof item.filters != 'undefined' && item.filters.length > 0) {\r\n                filters[item.uuid] = item.filters;\r\n                item.filters = [];\r\n            }\r\n        });\r\n\r\n        // this._removeEvents();\r\n\r\n        this.items._collection = [];\r\n\r\n        // if (sizeOldWorkArea) {\r\n        //     if (this.FabricBorder.width < this.FabricBorder.height) {\r\n        //         proportionsOnOld = this.FabricBorder.width / sizeOldWorkArea.width;\r\n        //     } else {\r\n        //         proportionsOnOld = this.FabricBorder.height / sizeOldWorkArea.height;\r\n        //     }\r\n        // }\r\n\r\n        let canvasData = JSON.stringify({ objects: data.canvas.objects });\r\n\r\n        this.FabricCanvas.loadFromJSON(canvasData, () => {\r\n            if (this.backdrop) {\r\n                this.FabricCanvas.backgroundImage = this.backdrop;\r\n            }\r\n            // this.setBorder(this.border);\r\n            this.FabricBorder.sendToBack();\r\n            this.FabricCanvas.renderAll.bind(this.FabricCanvas);\r\n            this._initEvents();\r\n            this.layers.update();\r\n\r\n            if (firstOfHistory) {\r\n                DrawTool.history.history[DrawTool.sides.selected.id].collection = [JSON.stringify(this.FabricCanvas)];\r\n                DrawTool.history.history[DrawTool.sides.selected.id].currentIndex = 0;\r\n            }\r\n        }, (o: any, item: any) => {\r\n            let scaleX = (this.getBorder().pixel.width / data.border.pixel.width);\r\n            let scaleY = (this.getBorder().pixel.height / data.border.pixel.height);\r\n            var valueScaleAction = scaleX;\r\n            if (scaleX > scaleY) valueScaleAction = scaleY;\r\n            scaleX = valueScaleAction * item.scaleX;\r\n            scaleY = valueScaleAction * item.scaleY;\r\n            if (valueScaleAction != 0) {\r\n                item.set({\r\n                    left: (this.center.x + item.left * valueScaleAction),\r\n                    top: (this.center.y + item.top * valueScaleAction),\r\n                    scaleX: scaleX,\r\n                    scaleY: scaleY,\r\n                    'sizeImage': 0,\r\n                    \"useItemData\": true,\r\n                    clipTo: this.overlay ? \"\" : clip(this.FabricBorder),\r\n                });\r\n            }\r\n            else {\r\n                item.set({\r\n                    left: this.center.x + ((item.left / data.factor.x) * ((this.getBorder().pixel.left || 1) / (this.defaultWorkspaceSize.left || 1))),\r\n                    top: this.center.y + ((item.top / data.factor.y) * ((this.getBorder().pixel.top || 1) / (this.defaultWorkspaceSize.top || 1))),\r\n                    scaleX: scaleX,\r\n                    scaleY: scaleY,\r\n                    'sizeImage': 0,\r\n                    \"useItemData\": true,\r\n                    clipTo: this.overlay ? \"\" : clip(this.FabricBorder),\r\n                });\r\n            }\r\n            if (!item.pathIndex || item.pathIndex !== DrawTool.modeSetup.EMBROIDER) {\r\n                this.items.setClipOtherBorder(item, this.FabricBorder, null);\r\n            }\r\n            if (item.lastBorder) {\r\n                if (DrawTool.modeToolDraw == DrawTool.modeSetup.EMBROIDER) {\r\n                    if (item.pathIndex == DrawTool.modeSetup.EMBROIDER) {\r\n                        var dataBoder = JSON.parse(item.lastBorder);\r\n                        dataBoder.isSetup = false;\r\n                        item.lastBorder = JSON.stringify(dataBoder);\r\n                    }\r\n                    else {\r\n                        this.items.setClipOtherBorder(item, this.FabricBorder);\r\n                    }\r\n                }\r\n                else {\r\n                    delete item.lastBorder;\r\n                }\r\n            }\r\n            var ImageProcessingColorCheck = false;\r\n            var checkChangeToCropPathProcessing = false;\r\n            var colorCheck = [\"rgba(0,0,0,1)\", \"rgba(255,0,0,1)\", \"rgba(0,0,255,1)\", \"rgba(255,255,255,1)\"];\r\n            if (DrawTool.modeToolDraw == DrawTool.modeSetup.TAP_RIBBON) {\r\n                colorCheck.push(\"rgba(255,255,255,1)\");\r\n            }\r\n            else if (DrawTool.modeToolDraw == DrawTool.modeSetup.TAP_RIBBON_2EDIT) {\r\n                colorCheck.push(\"rgba(193,171,5,1)\");\r\n                colorCheck.push(\"rgba(192,192,192,1)\");\r\n            }\r\n\r\n            // if (item.uuid in filters) {\r\n            //     Array.prototype.forEach.call(filters[item.uuid], (filter) => {\r\n            //         if (!colorCheck.includes(filter.color)) filter.color = \"rgba(0,0,0,1)\";\r\n            //         if (filter.type === \"RemoveColor\") {\r\n            //             // let filterRemoveColor = new fabric.fabric.Image.filters.RemoveWhite({\r\n            //             //     color: filter.color,\r\n            //             //     distance: filter.distance\r\n            //             // });\r\n            //             // item.filters.push(filterRemoveColor);\r\n            //             item.applyFilters(this.FabricCanvas.renderAll.bind(this.FabricCanvas));\r\n            //         }\r\n            //         else if (filter.type === \"ImageProcessingColor\") {\r\n            //             ImageProcessingColorCheck = true;\r\n            //             // let imageProcessingColor = new fabric.fabric.Image.filters.ImageProcessingColor({\r\n            //             //     color: filter.color,\r\n            //             //     distance: filter.distance\r\n            //             // });\r\n            //             // item.filters.push(imageProcessingColor);\r\n            //             item.applyFilters(this.FabricCanvas.renderAll.bind(this.FabricCanvas));\r\n            //         }\r\n            //         else if (filter.type === \"ImageChangeColorAll\") {\r\n            //             ImageProcessingColorCheck = true;\r\n            //             // let imageChangeColorAll = new fabric.fabric.Image.filters.ImageChangeColorAll({\r\n            //             //     color: filter.color,\r\n            //             //     distance: filter.distance\r\n            //             // });\r\n            //             // item.filters.push(imageChangeColorAll);\r\n            //             item.applyFilters(this.FabricCanvas.renderAll.bind(this.FabricCanvas));\r\n            //         }\r\n            //         else if (filter.type === \"ChangeToCropPathProcessing\") {\r\n            //             // checkChangeToCropPathProcessing = true;\r\n            //             // let changeToCropPathProcessing = new fabric.fabric.Image.filters.ChangeToCropPathProcessing({\r\n            //             //     color: filter.color,\r\n            //             //     distance: filter.distance\r\n            //             // });\r\n            //             // item.filters.push(changeToCropPathProcessing);\r\n            //             item.applyFilters(this.FabricCanvas.renderAll.bind(this.FabricCanvas));\r\n            //         }\r\n            //     });\r\n            // }\r\n            // if ((DrawTool.modeToolDraw == DrawTool.modeSetup.TAP_RIBBON) || (DrawTool.modeToolDraw == DrawTool.modeSetup.TAP_RIBBON_2EDIT)) {\r\n            //     if (!!item.type) {\r\n            //         if ((item.type === \"image\") && (!ImageProcessingColorCheck)) {\r\n            //             if (!!!item.filters) item.filters = [];\r\n            //             if (item.brush) {\r\n            //                 item.filters = [];\r\n            //                 var setColor = \"rgba(0,0,0,1)\";\r\n            //                 if (item.color) {\r\n            //                     if (colorCheck.includes(item.color)) setColor = item.color;\r\n            //                 }\r\n            //                 let imageChangeColorAll = new fabric.Image.filters.ImageChangeColorAll({\r\n            //                     color: setColor,\r\n            //                     distance: 10\r\n            //                 });\r\n            //                 item.filters.push(imageChangeColorAll);\r\n            //                 item.applyFilters(this.FabricCanvas.renderAll.bind(this.FabricCanvas));\r\n            //             }\r\n            //             else {\r\n            //                 if ((item.filters.length == 0) || checkChangeToCropPathProcessing) {\r\n            //                     let imageProcessingColor = new fabric.Image.filters.ImageProcessingColor({\r\n            //                         color: \"rgba(0,0,0,1)\",\r\n            //                         distance: 10\r\n            //                     });\r\n            //                     item.filters.push(imageProcessingColor);\r\n            //                     item.applyFilters(this.FabricCanvas.renderAll.bind(this.FabricCanvas));\r\n            //                 }\r\n            //             }\r\n            //         }\r\n            //         else if (item.type === \"path-group\") {\r\n            //             var enableSelectPath = false;\r\n            //             if (!!item.paths) {\r\n            //                 var countItemColor = 0;\r\n            //                 item.paths.forEach(function (path) {\r\n            //                     if (colorCheck.includes(path.fill)) {\r\n            //                         path.set('fill', path.fill);\r\n            //                         enableSelectPath = true;\r\n            //                     }\r\n            //                     else {\r\n            //                         path.set('fill', \"rgba(0,0,0,1)\");\r\n            //                     }\r\n            //                 });\r\n            //                 /*if(enableSelectPath==false){\r\n            //                   for(var i=0;i<colorAcess.length;i++){\r\n            //                     countItemColor=i%colorCheck.length;\r\n            //                     item.paths.forEach(function (path) {\r\n            //                       if (path.fill === colorAcess[countItemColor]) {\r\n            //                         path.set('fill', colorCheck[countItemColor]);\r\n            //                       }\r\n            //                     });\r\n            //                   }\r\n            //                 }*/\r\n            //             }\r\n            //         }\r\n            //         else if (item.type === \"i-text\") {\r\n            //             if (!!item.text) {\r\n            //                 if (!colorCheck.includes(item.fill)) item.set('fill', \"rgba(0,0,0,1)\");\r\n            //             }\r\n            //         }\r\n            //     }\r\n            // }\r\n\r\n\r\n\r\n            this.items._collection.push(item);\r\n            this.FabricCanvas.add(item)\r\n            if (data.is_empty) {\r\n                this.checkEmpty();\r\n            } else {\r\n\r\n                if ((!!this.border_special) && (this.border_special.length == 1)) {\r\n                    delete data.number_embroider_sp.left;\r\n                }\r\n                this.is_empty = data.is_empty;\r\n                this.number_embroider = data.number_embroider;\r\n                this.number_special_draw = data.number_special_draw;\r\n                this.number_draw = data.number_draw;\r\n                this.number_embroider_sp = data.number_embroider_sp;\r\n                this.number_print_draw = data.number_print_draw;\r\n            }\r\n\r\n            this.items.triggerCreated();\r\n            this.FabricCanvas.renderAll()\r\n            if (typeof callback == 'function')\r\n                callback();\r\n        });\r\n        this.checkEmpty()\r\n    }\r\n\r\n    checkEmpty() {\r\n        if (DrawTool.sides.selected) {\r\n            let border = DrawTool.sides.selected.FabricBorder\r\n            let count = 0\r\n            let countEmbroider = 0;\r\n            let countSpecialDraw = 0;\r\n            var countPrintDraw = 0;\r\n            var nameEmbroiderSide;\r\n            let side = DrawTool.sides.selected;\r\n            let border_coords = this.getValuefromHash(border.aCoords)\r\n            side.FabricCanvas._objects.map((item: any) => {\r\n                if (this.doPolygonsIntersect(border_coords, this.getValuefromHash(item.aCoords)) && item.id != \"FabricBorder\") {\r\n                    if (item.pathIndex == 1) {\r\n                        countEmbroider++;\r\n                    }\r\n                    if (item.pathIndex == -1) {\r\n                        countPrintDraw++;\r\n                    }\r\n                    else if (item.pathIndex > 2) countSpecialDraw++;\r\n                    count++;\r\n                }\r\n            });\r\n            if (count == 0) {\r\n                side.is_empty = true;\r\n            } else {\r\n                side.is_empty = false;\r\n            }\r\n\r\n            side.number_embroider = countEmbroider;\r\n            side.number_special_draw = countSpecialDraw;\r\n            side.number_draw = count;\r\n\r\n            if (!DrawTool.is_embroidery) {\r\n                side.number_print_draw = countPrintDraw;\r\n            }\r\n            if (!side.number_embroider_sp) {\r\n                side.number_embroider_sp = {};\r\n            }\r\n            if (side.border.name) {\r\n                side.number_embroider_sp[side.border.name] = countEmbroider;\r\n            }\r\n\r\n            if (side.id === '3') {\r\n                nameEmbroiderSide = 'handLeft';\r\n                side.nameSide = 'handLeft'\r\n            }\r\n            if (side.id === '4') {\r\n                nameEmbroiderSide = 'handRight';\r\n                side.nameSide = 'handRight'\r\n            }\r\n            if (nameEmbroiderSide) {\r\n                side.number_embroider_sp[nameEmbroiderSide] = countEmbroider;\r\n            }\r\n        }\r\n    }\r\n\r\n    getValuefromHash(hash: any) {\r\n        var array_values = [];\r\n        for (var key in hash) {\r\n            array_values.push(hash[key]);\r\n        }\r\n        return array_values;\r\n    }\r\n\r\n    doPolygonsIntersect(a: any, b: any) {\r\n        let polygons = [a, b];\r\n        let minA, maxA, projected, i, i1, j, minB, maxB;\r\n        for (i = 0; i < polygons.length; i++) {\r\n            // for each polygon, look at each edge of the polygon, and determine if it separates\r\n            // the two shapes\r\n            let polygon = polygons[i];\r\n            for (i1 = 0; i1 < polygon.length; i1++) {\r\n                // grab 2 vertices to create an edge\r\n                let i2 = (i1 + 1) % polygon.length;\r\n                let p1 = polygon[i1];\r\n                let p2 = polygon[i2];\r\n                // find the line perpendicular to this edge\r\n                let normal = { x: p2.y - p1.y, y: p1.x - p2.x };\r\n                minA = maxA = undefined;\r\n                // for each vertex in the first shape, project it onto the line perpendicular to the edge\r\n                // and keep track of the min and max of these values\r\n                for (j = 0; j < a.length; j++) {\r\n                    projected = normal.x * a[j].x + normal.y * a[j].y;\r\n                    if ((!minA) || projected < minA) {\r\n                        minA = projected;\r\n                    }\r\n                    if ((!maxA) || projected > maxA) {\r\n                        maxA = projected;\r\n                    }\r\n                }\r\n                // for each vertex in the second shape, project it onto the line perpendicular to the edge\r\n                // and keep track of the min and max of these values\r\n                minB = maxB = undefined;\r\n                for (j = 0; j < b.length; j++) {\r\n                    projected = normal.x * b[j].x + normal.y * b[j].y;\r\n                    if ((!minB) || projected < minB) {\r\n                        minB = projected;\r\n                    }\r\n                    if ((!maxB) || projected > maxB) {\r\n                        maxB = projected;\r\n                    }\r\n                }\r\n\r\n                // if there is no overlap between the projects, the edge we are looking at separates the two\r\n                // polygons, and we know there is no overlap\r\n                if (maxA! < minB! || maxB! < minA!) {\r\n                    console.log(\"polygons don't intersect!\");\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // toJSON() {\r\n    //     DrawTool.is_data.map((side: Side) => {\r\n    //         if (side.border_special) {\r\n    //             let borderEmbroider1: any = { sideId: side.id, border: side.border_special, bd: side.border }\r\n    //             DrawTool._embroideryPaths.push(borderEmbroider1);\r\n\r\n    //         } else {\r\n    //             var pathEmbroider = `M${side.border.cm.left} ${side.border.cm.top} h${side.border.cm.width} v${side.border.cm.height} h-${side.border.cm.width} Z`;\r\n    //             if (DrawTool.embroider_able) {\r\n    //                 side.border.paths = [pathEmbroider];\r\n    //             }\r\n    //             var borderEmbroider2 = { sideId: side.id, border: [{ cm: side.border.cm, paths: side.border.paths, pixel: side.border.pixel, name: \"\" }], bd: side.border };\r\n    //             DrawTool._embroideryPaths.push(borderEmbroider2);\r\n    //         }\r\n    //     });\r\n\r\n    //     let _formattedSide: any = {\r\n    //         id: this.id,\r\n    //         imageUrl: this.imageUrl,\r\n    //         size: this.size,\r\n    //         is_empty: this.is_empty,\r\n    //         number_embroider: this.number_embroider,\r\n    //         number_special_draw: this.number_special_draw,\r\n    //         number_draw: this.number_draw,\r\n    //         number_embroider_sp: this.number_embroider_sp,\r\n    //         number_print_draw: this.number_print_draw,\r\n    //         canvas: this.FabricCanvas.toObject(['brush', 'editable', 'vertical', 'color', 'typeSVG', 'pathIndex', 'fileContent', 'fileContentURL', 'typePaths', 'lastBorder', 'areaEmbroider', 'pathDLaser']),\r\n    //         fonts: DrawTool.fonts,\r\n    //         border_special: this.border_special,\r\n    //     };\r\n\r\n    //     var itemOrder = [];\r\n\r\n    //     for (var i = 0; i < _formattedSide.canvas.objects.length; i++) {\r\n    //         if (_formattedSide.canvas.objects[i].pathIndex) {\r\n    //             if (_formattedSide.canvas.objects[i].pathIndex < 1) {\r\n    //                 itemOrder.push(_formattedSide.canvas.objects[i]);\r\n    //             }\r\n    //         }\r\n    //         else {\r\n    //             itemOrder.push(_formattedSide.canvas.objects[i]);\r\n    //         }\r\n    //     }\r\n\r\n    //     for (var i = 0; i < _formattedSide.canvas.objects.length; i++) {\r\n    //         if ((_formattedSide.canvas.objects[i].pathIndex) && (_formattedSide.canvas.objects[i].pathIndex > 0)) {\r\n    //             itemOrder.push(_formattedSide.canvas.objects[i]);\r\n    //         }\r\n\r\n    //     }\r\n    //     _formattedSide.canvas.objects = itemOrder;\r\n\r\n    //     _formattedSide.canvas.objects.forEach((item: any, i: any) => {\r\n    //         item.left = item.left - this.center.x;\r\n    //         item.top = item.top - this.center.y;\r\n    //         item.clipTo = null;\r\n    //         if (!item.type.includes('text') && !!item.fill) {\r\n    //             item.fill = null\r\n    //         }\r\n\r\n    //         if (item.selected) {\r\n    //             item.selectable = false;\r\n    //         }\r\n\r\n    //         if (item.type.includes('text') && DrawTool.rasterizedText) {\r\n    //             if (DrawTool.rasterizedText![item.uuid]) {\r\n    //                 let textObject = fabric.fabric.util.object.clone(item);\r\n    //                 item.visible = false;\r\n\r\n    //                 textObject.type = 'image';\r\n    //                 textObject.fill = 'rgb(0,0,0)';\r\n    //                 textObject.strokeWidth = 0;\r\n    //                 textObject.crossOrigin = 'anonymous';\r\n    //                 textObject.src = DrawTool.rasterizedText![item.uuid];\r\n    //                 textObject.alignX = 'none';\r\n    //                 textObject.alignY = 'none';\r\n    //                 textObject.meetOrSlice = 'meet';\r\n    //                 textObject.filters = [];\r\n    //                 textObject.resizeFilters = [];\r\n    //                 textObject.width = textObject.width * textObject.scaleX + textObject.width * textObject.scaleX * 0.1;\r\n    //                 textObject.height = textObject.height * textObject.scaleY + textObject.height * textObject.scaleY * 0.1;\r\n    //                 textObject.scaleX = 1;\r\n    //                 textObject.scaleY = 1;\r\n    //                 let cos = Math.cos(textObject.angle * Math.PI / 180);\r\n    //                 let sin = Math.sin(textObject.angle * Math.PI / 180);\r\n\r\n    //                 textObject.left += textObject.width * textObject.scaleX * 0.05 * cos;\r\n    //                 textObject.top += textObject.width * textObject.scaleX * 0.05 * sin;\r\n\r\n    //                 delete textObject['text'];\r\n    //                 delete textObject['fontSize'];\r\n    //                 delete textObject['fontWeight'];\r\n    //                 delete textObject['fontFamily'];\r\n    //                 delete textObject['fontStyle'];\r\n    //                 delete textObject['lineHeight'];\r\n    //                 delete textObject['textDecoration'];\r\n    //                 delete textObject['textAlign'];\r\n    //                 delete textObject['textBackgroundColor'];\r\n    //                 delete textObject['charSpacing'];\r\n    //                 delete textObject['editable'];\r\n    //                 delete textObject['vertical'];\r\n    //                 delete textObject['styles'];\r\n\r\n    //                 textObject.pathIndex = item.pathIndex;\r\n    //                 textObject.areaEmbroider = item.areaEmbroider\r\n    //                 _formattedSide.canvas.objects[i] = textObject;\r\n    //                 _formattedSide.canvas.objects.push(item);\r\n    //             }\r\n    //         }\r\n    //         if (item.brush) item.pathIndex = -1;\r\n    //     });\r\n\r\n    //     _formattedSide.canvas.objects_print = [];\r\n    //     _formattedSide.canvas.objects_embroidery = [];\r\n    //     _formattedSide.canvas.objects_special_draw = [];\r\n    //     _formattedSide.canvas.objects.forEach((item: any, i: any) => {\r\n    //         if ((item.brush) || (item.pathIndex === -1)) {\r\n    //             _formattedSide.canvas.objects_print.push(item);\r\n    //         } else {\r\n\r\n    //             if ((item.pathIndex) && (item.pathIndex == DrawTool.modeSetup.LASER)) {\r\n    //                 _formattedSide.border = this.getBorder();\r\n    //                 item.pathBorderLaser = {\r\n    //                     size: this.size, border: _formattedSide.border.cm,\r\n    //                     center: this.center, _pan_x0: this._pan_x0, _pan_y0: this._pan_y0,\r\n    //                     borderPixel: _formattedSide.border.pixel\r\n    //                 };\r\n    //                 _formattedSide.canvas.objects_special_draw.push(item);\r\n    //             }\r\n    //             else if ((item.pathIndex) && (item.pathIndex == DrawTool.modeSetup.EMBROIDER)) {\r\n    //                 _formattedSide.canvas.objects_embroidery.push(item);\r\n    //             }\r\n    //             else {\r\n    //                 _formattedSide.canvas.objects_print.push(item);\r\n    //             }\r\n    //         }\r\n    //     });\r\n\r\n    //     if (this.backdrop) {\r\n    //         _formattedSide.imageUrl = this.imageUrl\r\n    //     }\r\n\r\n    //     if (this.FabricBorder) {\r\n    //         _formattedSide.border = this.getBorder();\r\n    //         _formattedSide.factor = {\r\n    //             x: this.getBorder().pixel.width / this.defaultWorkspaceSize.width,\r\n    //             y: this.getBorder().pixel.height / this.defaultWorkspaceSize.height,\r\n    //         }\r\n    //     }\r\n\r\n    //     _formattedSide.about = {\r\n    //         appVersion: navigator.appVersion,\r\n    //         userAgent: navigator.userAgent,\r\n    //         language: navigator.language,\r\n    //         languages: navigator.languages,\r\n    //     };\r\n    //     DrawTool._embroideryPaths.splice(4);\r\n    //     let designSide = DrawTool._designBorders.find((b: any) => b.sideId === this.id);\r\n    //     let designSideEmbroider = DrawTool._embroideryPaths.find((b: any) => b.sideId === this.id);\r\n    //     if (typeof designSide !== 'undefined') {\r\n    //         let paths = DrawTool.recs2paths(designSide.border);\r\n    //         const pathOset = 1.1;\r\n    //         var ptS = '';\r\n    //         designSideEmbroider.border.forEach((el: any) => {\r\n    //             if (el.paths && el.cm) {\r\n    //                 ptS += el.paths + ' ';\r\n    //             }\r\n    //         });\r\n    //         if ((DrawTool.modeToolDraw == DrawTool.modeSetup.EMBROIDER)) {\r\n    //             var patN: any = {\r\n    //                 paths: [ptS],\r\n    //                 cm: designSideEmbroider.bd.cm,\r\n    //                 pixel: designSideEmbroider.bd.pixel\r\n    //             };\r\n    //             if (designSideEmbroider.sideId !== '1') {\r\n    //                 delete patN.paths;\r\n    //             }\r\n    //             _formattedSide.design_border = patN;\r\n    //         }\r\n\r\n    //     }\r\n    //     return JSON.stringify(_formattedSide);\r\n    // }\r\n\r\n    getBorder() {\r\n        let paddingTop = (this.FabricCanvas.height - (this.backdrop.height * this.backdrop.scaleY)) / 2;\r\n        let paddingLeft = (this.FabricCanvas.width - (this.backdrop.width * this.backdrop.scaleX)) / 2;\r\n        let border = {\r\n            cm: {\r\n                left: (this.FabricBorder.left + this.bgOffset.left - paddingLeft) / this.cmSize.width,\r\n                top: (this.FabricBorder.top + this.bgOffset.top - paddingTop) / this.cmSize.height,\r\n                width: (this.FabricBorder.width * this.FabricBorder.scaleX) / this.cmSize.width,\r\n                height: (this.FabricBorder.height * this.FabricBorder.scaleY) / this.cmSize.height,\r\n            },\r\n            pixel: {\r\n                left: this.FabricBorder.left + this.bgOffset.left - paddingLeft,\r\n                top: this.FabricBorder.top + this.bgOffset.top - paddingTop,\r\n                width: this.FabricBorder.width * this.FabricBorder.scaleX,\r\n                height: this.FabricBorder.height * this.FabricBorder.scaleY,\r\n            }\r\n        };\r\n\r\n        if (typeof this.border.paths !== 'undefined' && this.border.paths.length > 0)\r\n            (border as any).paths = this.border.paths;\r\n\r\n        return border\r\n    }\r\n\r\n\r\n    // getOccupiedAreaSize() {\r\n    //     let occupiedAreaSize = {\r\n    //         width: 0,\r\n    //         height: 0\r\n    //     };\r\n\r\n    //     let maxOccupiedAreaCoordinates = false;\r\n\r\n    //     Array.prototype.forEach.call(this.items._collection, (item) => {\r\n    //         if (this.isExistItem(item) && item.intersectsWithObject(this.FabricBorder)) {\r\n    //             let coordinatesOccupiedArea = this.createCoordinates(item.aCoords);\r\n\r\n    //             if (coordinatesOccupiedArea.tl.x < this.FabricBorder.aCoords.tl.x) {\r\n    //                 coordinatesOccupiedArea.tl.x = this.FabricBorder.aCoords.tl.x;\r\n    //                 coordinatesOccupiedArea.bl.x = this.FabricBorder.aCoords.bl.x;\r\n    //             }\r\n\r\n    //             if (coordinatesOccupiedArea.tl.y < this.FabricBorder.aCoords.tl.y) {\r\n    //                 coordinatesOccupiedArea.tl.y = this.FabricBorder.aCoords.tl.y;\r\n    //                 coordinatesOccupiedArea.tr.y = this.FabricBorder.aCoords.tr.y;\r\n    //             }\r\n\r\n    //             if (coordinatesOccupiedArea.br.x > this.FabricBorder.aCoords.br.x) {\r\n    //                 coordinatesOccupiedArea.br.x = this.FabricBorder.aCoords.br.x;\r\n    //                 coordinatesOccupiedArea.tr.x = this.FabricBorder.aCoords.tr.x;\r\n    //             }\r\n\r\n    //             if (coordinatesOccupiedArea.br.y > this.FabricBorder.aCoords.br.y) {\r\n    //                 coordinatesOccupiedArea.br.y = this.FabricBorder.aCoords.br.y;\r\n    //                 coordinatesOccupiedArea.bl.y = this.FabricBorder.aCoords.bl.y;\r\n    //             }\r\n\r\n    //             if (!maxOccupiedAreaCoordinates) {\r\n    //                 maxOccupiedAreaCoordinates = coordinatesOccupiedArea;\r\n    //             } else {\r\n    //                 if (coordinatesOccupiedArea.tl.x < maxOccupiedAreaCoordinates.tl.x) {\r\n    //                     maxOccupiedAreaCoordinates.tl.x = coordinatesOccupiedArea.tl.x;\r\n    //                     maxOccupiedAreaCoordinates.bl.x = coordinatesOccupiedArea.tl.x;\r\n    //                 }\r\n\r\n    //                 if (coordinatesOccupiedArea.tl.y < maxOccupiedAreaCoordinates.tl.y) {\r\n    //                     maxOccupiedAreaCoordinates.tl.y = coordinatesOccupiedArea.tl.y;\r\n    //                     maxOccupiedAreaCoordinates.tr.y = coordinatesOccupiedArea.tr.y;\r\n    //                 }\r\n\r\n    //                 if (coordinatesOccupiedArea.br.x > maxOccupiedAreaCoordinates.br.x) {\r\n    //                     maxOccupiedAreaCoordinates.br.x = coordinatesOccupiedArea.br.x;\r\n    //                     maxOccupiedAreaCoordinates.tr.x = coordinatesOccupiedArea.tr.x;\r\n    //                 }\r\n\r\n    //                 if (coordinatesOccupiedArea.br.y > maxOccupiedAreaCoordinates.br.y) {\r\n    //                     maxOccupiedAreaCoordinates.br.y = coordinatesOccupiedArea.br.y;\r\n    //                     maxOccupiedAreaCoordinates.bl.y = coordinatesOccupiedArea.br.y;\r\n    //                 }\r\n    //             }\r\n    //         }\r\n    //     });\r\n\r\n    //     let workAreaCenter = this.FabricBorder.getCenterPoint();\r\n\r\n    //     if (maxOccupiedAreaCoordinates) {\r\n    //         occupiedAreaSize.width = Math.max(Math.abs(workAreaCenter.x - maxOccupiedAreaCoordinates.tl.x), Math.abs(workAreaCenter.x - maxOccupiedAreaCoordinates.tr.x)) * 2;\r\n    //         occupiedAreaSize.height = Math.max(Math.abs(workAreaCenter.y - maxOccupiedAreaCoordinates.tl.y), Math.abs(workAreaCenter.y - maxOccupiedAreaCoordinates.bl.y)) * 2;\r\n    //     }\r\n\r\n    //     return occupiedAreaSize;\r\n    // }\r\n}\r\n\r\nexport default Side","D:\\React\\demo-upt\\src\\Drawtool\\draw-tool\\Items.ts",[],"D:\\React\\demo-upt\\src\\Drawtool\\draw-tool\\Layers.ts",["92"],"import DrawTool from './DrawTool';\r\nimport Side from './Side';\r\n\r\nclass Layers {\r\n    side: Side\r\n    list: any\r\n    constructor(side: Side) {\r\n        this.side = side;\r\n        this.list = null;\r\n        this.update();\r\n    }\r\n\r\n    update() {\r\n        let layers: any = [];\r\n\r\n        let opt = {\r\n            quality: 0.5,\r\n            enableRetinaScaling: false\r\n        };\r\n\r\n        this.side.FabricCanvas.forEachObject((obj: any) => {\r\n            if (!obj.excludeFromExport) {\r\n                let clipto = obj.getClipTo();\r\n                obj.setClipTo(null);\r\n                layers.push({ index: obj.uuid, preview: obj.toDataURL(opt) });\r\n                obj.setClipTo(clipto);\r\n            }\r\n        });\r\n        this.list = layers;\r\n\r\n        return layers;\r\n    }\r\n\r\n    _getItemsByIndex(indexes: any) {\r\n        let objects = this.side.FabricCanvas.getObjects().filter((obj: any) => indexes.includes(obj.uuid));\r\n        return objects;\r\n    }\r\n\r\n    // bringToFront(...indexes:any) {\r\n    //     let items = this._getItemsByIndex(indexes);\r\n    //     let offset = this.side.FabricCanvas.getObjects().filter(o => o.excludeFromExport).length;\r\n    //     let newIndexes = [];\r\n\r\n    //     items.forEach(item => {\r\n    //         item.bringToFront();\r\n    //         newIndexes.push({ uuid: item.uuid, index: this.side.FabricCanvas.getObjects().findIndex(o => o.uuid === item.uuid) - offset });\r\n    //     });\r\n    //     DrawTool.trigger('object:indexUpdate', JSON.stringify({ side: { id: this.side.id }, items: newIndexes }));\r\n    //     DrawTool.trigger('history:update', { side: { id: this.side.id } });\r\n    // }\r\n\r\n    // bringForward(...indexes) {\r\n    //     let items = this._getItemsByIndex(indexes);\r\n    //     let offset = this.side.FabricCanvas.getObjects().filter(o => o.excludeFromExport).length;\r\n    //     let newIndexes = [];\r\n\r\n    //     items.forEach(item => {\r\n    //         item.bringForward()\r\n    //         newIndexes.push({ uuid: item.uuid, index: this.side.FabricCanvas.getObjects().findIndex(o => o.uuid === item.uuid) - offset });\r\n    //     });\r\n    //     DrawTool.trigger('object:indexUpdate', JSON.stringify({ side: { id: this.side.id }, items: newIndexes }));\r\n    //     DrawTool.trigger('history:update', { side: { id: this.side.id } });\r\n    // }\r\n\r\n    // sendBackwards(...indexes) {\r\n    //     let items = this._getItemsByIndex(indexes);\r\n    //     let offset = this.side.FabricCanvas.getObjects().filter(o => o.excludeFromExport).length;\r\n    //     let newIndexes = [];\r\n\r\n    //     items.forEach(item => {\r\n    //         item.sendBackwards()\r\n    //         newIndexes.push({ uuid: item.uuid, index: this.side.FabricCanvas.getObjects().findIndex(o => o.uuid === item.uuid) - offset });\r\n    //     });\r\n    //     DrawTool.trigger('object:indexUpdate', JSON.stringify({ side: { id: this.side.id }, items: newIndexes }));\r\n    //     DrawTool.trigger('history:update', { side: { id: this.side.id } });\r\n    // }\r\n\r\n    // sendToBack(...indexes) {\r\n    //     let items = this._getItemsByIndex(indexes);\r\n    //     let offset = this.side.FabricCanvas.getObjects().filter(o => o.excludeFromExport).length;\r\n    //     let newIndexes = [];\r\n\r\n    //     items.forEach(item => {\r\n    //         item.sendToBack()\r\n    //         newIndexes.push({ uuid: item.uuid, index: this.side.FabricCanvas.getObjects().findIndex(o => o.uuid === item.uuid) - offset });\r\n    //     });\r\n    //     DrawTool.trigger('object:indexUpdate', JSON.stringify({ side: { id: this.side.id }, items: newIndexes }));\r\n    //     DrawTool.trigger('history:update', { side: { id: this.side.id } });\r\n    // }\r\n\r\n\r\n    // moveToIndex(data) {\r\n    //     let item = this._getItemsByIndex(data.uuid)[0];\r\n\r\n    //     if (!item) return;\r\n\r\n    //     let offset = this.side.FabricCanvas.getObjects().filter(o => o.excludeFromExport).length;\r\n\r\n    //     let oldIndex = this.side.FabricCanvas.getObjects().findIndex(o => o.uuid === item.uuid) - offset;\r\n    //     let diff = data.index - oldIndex;\r\n\r\n    //     if (diff > 0) {\r\n    //         for (let i = 0; i < diff; i++) {\r\n    //             item.bringForward();\r\n    //         }\r\n    //     } else if (diff < 0) {\r\n    //         for (let i = 0; i > diff; i--) {\r\n    //             item.sendBackwards();\r\n    //         }\r\n    //     }\r\n\r\n    //     DrawTool.trigger('history:update', { side: { id: this.side.id } });\r\n    // }\r\n\r\n    // toVCenter(...indexes) {\r\n    //     let items = this._getItemsByIndex(indexes);\r\n\r\n    //     items.forEach(item => item.set('top', this.side.FabricBorder.top + this.side.FabricBorder.height / 2));\r\n    //     this.side.FabricCanvas.renderAll();\r\n    // }\r\n\r\n    // toHCenter(...indexes) {\r\n    //     let items = this._getItemsByIndex(indexes);\r\n\r\n    //     items.forEach(item => {\r\n    //         item.set('left', this.side.FabricBorder.left + this.side.FabricBorder.width / 2);\r\n    //         this.side.FabricCanvas.trigger('object:modified', { target: item });\r\n    //     });\r\n    //     this.side.FabricCanvas.renderAll();\r\n    // }\r\n\r\n    // toLeft(...indexes) {\r\n    //     let items = this._getItemsByIndex(indexes);\r\n\r\n    //     items.forEach(item => {\r\n    //         item.set('left', this.side.FabricBorder.left + (item.width * item.scaleX) / 2);\r\n    //         this.side.FabricCanvas.trigger('object:modified', { target: item });\r\n    //     });\r\n    //     this.side.FabricCanvas.renderAll();\r\n    // }\r\n\r\n    // toRight(...indexes) {\r\n    //     let items = this._getItemsByIndex(indexes);\r\n\r\n    //     items.forEach(item => {\r\n    //         item.set('left', this.side.FabricBorder.left + this.side.FabricBorder.width - (item.width * item.scaleX) / 2);\r\n    //         this.side.FabricCanvas.trigger('object:modified', { target: item });\r\n    //     });\r\n    //     this.side.FabricCanvas.renderAll();\r\n    // }\r\n\r\n    // toTop(...indexes) {\r\n    //     let items = this._getItemsByIndex(indexes);\r\n\r\n    //     items.forEach(item => {\r\n    //         item.set('top', this.side.FabricBorder.top + (item.height * item.scaleY) / 2);\r\n    //         this.side.FabricCanvas.trigger('object:modified', { target: item });\r\n    //     });\r\n    //     this.side.FabricCanvas.renderAll();\r\n    // }\r\n\r\n    // toBottom(...indexes) {\r\n    //     let items = this._getItemsByIndex(indexes);\r\n\r\n    //     items.forEach(item => {\r\n    //         item.set('top', this.side.FabricBorder.top + this.side.FabricBorder.height - (item.height * item.scaleY) / 2);\r\n    //         this.side.FabricCanvas.trigger('object:modified', { target: item });\r\n    //     });\r\n    //     this.side.FabricCanvas.renderAll();\r\n    // }\r\n\r\n}\r\nexport default Layers;\r\n","D:\\React\\demo-upt\\src\\Drawtool\\utils\\clip.ts",["93","94","95"],"export default function (border: any, offset = true) {\r\n\r\n    if (typeof border._objects !== 'undefined' && border._objects.length > 0 && border._objects[0].type === 'path') {\r\n        var generate = function () {\r\n            return `\r\n          if(!!this.lastBorder){\r\n              var dataBoder=JSON.parse(this.lastBorder);\r\n              if(dataBoder.isPath){\r\n                    var border = dataBoder.border;\r\n                    var offsetY = dataBoder.offsetY;\r\n                    var offsetX = dataBoder.offsetX;\r\n        \r\n                    this.setCoords();\r\n                    ctx.save();\r\n                    var m = this.calcTransformMatrix();\r\n                    var iM = fabric.util.invertTransform(m);\r\n                    ctx.transform.apply(ctx, iM);\r\n                    ctx.beginPath();\r\n                    for(var i=0;i<dataBoder.allBorder.length;i++){\r\n                      let path = dataBoder.allBorder[i];\r\n                      var valueX=offsetX - dataBoder.minX * border.scaleX + (dataBoder.drawToolBorder.strokeWidth / 2) * border.scaleX;\r\n                      var valueY=offsetY - dataBoder.minY * border.scaleY + (dataBoder.drawToolBorder.strokeWidth / 2) * border.scaleY;\r\n                      DrawTool.drawPathOnCtx.call(\r\n                        path,\r\n                        ctx,\r\n                        valueX,\r\n                        valueY,\r\n                        border.scaleX,\r\n                        border.scaleY\r\n                      );\r\n  \r\n                    }\r\n        \r\n                    ctx.closePath();\r\n                    ctx.restore();\r\n              }\r\n              else\r\n              {\r\n                  this.setCoords();\r\n                  var clipRect = dataBoder.border;\r\n                  var offsetY = dataBoder.offsetY;\r\n                  var offsetX = dataBoder.offsetX;\r\n                  ctx.save();\r\n                  var m = this.calcTransformMatrix();\r\n                  var iM = fabric.util.invertTransform(m);\r\n                  ctx.transform.apply(ctx, iM);\r\n                  ctx.beginPath();\r\n          \r\n                  ctx.rect(\r\n                    offsetX,\r\n                    offsetY,\r\n                    clipRect.width - clipRect.strokeWidth,\r\n                    clipRect.height - clipRect.strokeWidth\r\n                  );\r\n                  ctx.closePath();\r\n                  ctx.restore();\r\n              }\r\n          }\r\n          else\r\n          {\r\n            if((!!DrawTool.sides.selected.FabricBorder._objects)&&(DrawTool.sides.selected.FabricBorder._objects.length>0)){\r\n              var border = fabric.util.object.clone(DrawTool.sides.selected.FabricBorder._objects[0]);\r\n              var offset = ${JSON.stringify(offset)};\r\n              if(offset){\r\n                var offsetY = DrawTool.sides.selected.FabricBorder.top;\r\n                var offsetX = DrawTool.sides.selected.FabricBorder.left;\r\n              } else {\r\n                var offsetY = 0;\r\n                var offsetX = 0;\r\n              }\r\n  \r\n              this.setCoords();\r\n              ctx.save();\r\n              var m = this.calcTransformMatrix();\r\n              var iM = fabric.util.invertTransform(m);\r\n              ctx.transform.apply(ctx, iM);\r\n              ctx.beginPath();\r\n  \r\n              Array.prototype.forEach.call(DrawTool.sides.selected.FabricBorder._objects, function(path, i) {\r\n                DrawTool.drawPathOnCtx.call(\r\n                  path,\r\n                  ctx,\r\n                  offsetX - border.minX * border.scaleX + (DrawTool.border.strokeWidth / 2) * border.scaleX,\r\n                  offsetY - border.minY * border.scaleY + (DrawTool.border.strokeWidth / 2) * border.scaleY,\r\n                  border.scaleX,\r\n                  border.scaleY\r\n                );\r\n              });\r\n  \r\n              ctx.closePath();\r\n              ctx.restore();\r\n            }\r\n            else\r\n            {\r\n  \r\n              this.setCoords();\r\n                var offsetY = DrawTool.sides.selected.FabricBorder.top;\r\n                var offsetX = DrawTool.sides.selected.FabricBorder.left;\r\n                ctx.save();\r\n                var m = this.calcTransformMatrix();\r\n                var iM = fabric.util.invertTransform(m);\r\n                ctx.transform.apply(ctx, iM);\r\n                ctx.beginPath();\r\n        \r\n                ctx.rect(\r\n                  offsetX,\r\n                  offsetY,\r\n                  DrawTool.sides.selected.FabricBorder.width - DrawTool.sides.selected.FabricBorder.strokeWidth,\r\n                  DrawTool.sides.selected.FabricBorder.height - DrawTool.sides.selected.FabricBorder.strokeWidth\r\n                );\r\n                ctx.closePath();\r\n                ctx.restore();\r\n  \r\n            }\r\n          }\r\n          `;\r\n        }\r\n    } else {\r\n        var rect = Object.assign({}, {\r\n            left: border.left,\r\n            top: border.top,\r\n            width: border.width,\r\n            height: border.height,\r\n            strokeWidth: border.strokeWidth,\r\n        });\r\n\r\n        var generate = function () {\r\n            return `\r\n          if(!!this.lastBorder){\r\n            var dataBoder=JSON.parse(this.lastBorder);\r\n            if(dataBoder.isPath){\r\n                    var border = dataBoder.border;\r\n                    var offsetY = dataBoder.offsetY;\r\n                    var offsetX = dataBoder.offsetX;\r\n        \r\n                    this.setCoords();\r\n                    ctx.save();\r\n                    var m = this.calcTransformMatrix();\r\n                    var iM = fabric.util.invertTransform(m);\r\n                    ctx.transform.apply(ctx, iM);\r\n                    ctx.beginPath();\r\n                    for(var i=0;i<dataBoder.allBorder.length;i++){\r\n                      let path = dataBoder.allBorder[i];\r\n                      var valueX=offsetX - dataBoder.minX * border.scaleX + (dataBoder.drawToolBorder.strokeWidth / 2) * border.scaleX;\r\n                      var valueY=offsetY - dataBoder.minY * border.scaleY + (dataBoder.drawToolBorder.strokeWidth / 2) * border.scaleY;\r\n                      DrawTool.drawPathOnCtx.call(\r\n                        path,\r\n                        ctx,\r\n                        valueX,\r\n                        valueY,\r\n                        border.scaleX,\r\n                        border.scaleY\r\n                      );\r\n                    }\r\n        \r\n                    ctx.closePath();\r\n                    ctx.restore();\r\n            }\r\n            else\r\n            {\r\n              this.setCoords();\r\n              var clipRect = dataBoder.border;\r\n              var offsetY = dataBoder.offsetY;\r\n              var offsetX = dataBoder.offsetX;\r\n              ctx.save();\r\n              var m = this.calcTransformMatrix();\r\n              var iM = fabric.util.invertTransform(m);\r\n              ctx.transform.apply(ctx, iM);\r\n              ctx.beginPath();\r\n      \r\n              ctx.rect(\r\n                offsetX,\r\n                offsetY,\r\n                clipRect.width - clipRect.strokeWidth,\r\n                clipRect.height - clipRect.strokeWidth\r\n              );\r\n              ctx.closePath();\r\n              ctx.restore();\r\n            }\r\n          }\r\n          else\r\n          {\r\n             this.setCoords();\r\n              var clipRect = ${JSON.stringify(rect)};\r\n              var offset = ${JSON.stringify(offset)};\r\n      \r\n              if(offset){\r\n                var offsetY = clipRect.top;\r\n                var offsetX = clipRect.left;\r\n              } else {\r\n                var offsetY = 0;\r\n                var offsetX = 0;\r\n              }\r\n              ctx.save();\r\n              var m = this.calcTransformMatrix();\r\n              var iM = fabric.util.invertTransform(m);\r\n              ctx.transform.apply(ctx, iM);\r\n              ctx.beginPath();\r\n      \r\n              ctx.rect(\r\n                offsetX,\r\n                offsetY,\r\n                clipRect.width - clipRect.strokeWidth,\r\n                clipRect.height - clipRect.strokeWidth\r\n              );\r\n              ctx.closePath();\r\n              ctx.restore();\r\n          }\r\n  \r\n          `\r\n        }\r\n    }\r\n    return new Function('ctx', generate());\r\n};\r\n","D:\\React\\demo-upt\\src\\Drawtool\\draw-tool\\Item.ts",[],{"ruleId":"96","replacedBy":"97"},{"ruleId":"98","replacedBy":"99"},{"ruleId":"100","severity":1,"message":"101","line":5,"column":8,"nodeType":"102","messageId":"103","endLine":5,"endColumn":18},{"ruleId":"104","severity":1,"message":"105","line":258,"column":51,"nodeType":"106","messageId":"107","endLine":258,"endColumn":53},{"ruleId":"104","severity":1,"message":"108","line":278,"column":71,"nodeType":"106","messageId":"109","endLine":278,"endColumn":73},{"ruleId":"110","severity":1,"message":"111","line":279,"column":23,"nodeType":"112","messageId":"113","endLine":279,"endColumn":25},{"ruleId":"114","severity":1,"message":"115","line":16,"column":5,"nodeType":"116","messageId":"117","endLine":18,"endColumn":6},{"ruleId":"118","severity":1,"message":"119","line":26,"column":57,"nodeType":"120","endLine":26,"endColumn":67},{"ruleId":"104","severity":1,"message":"108","line":99,"column":49,"nodeType":"106","messageId":"109","endLine":99,"endColumn":51},{"ruleId":"104","severity":1,"message":"108","line":149,"column":44,"nodeType":"106","messageId":"109","endLine":149,"endColumn":46},{"ruleId":"110","severity":1,"message":"121","line":159,"column":48,"nodeType":"112","messageId":"113","endLine":159,"endColumn":50},{"ruleId":"110","severity":1,"message":"121","line":159,"column":108,"nodeType":"112","messageId":"113","endLine":159,"endColumn":110},{"ruleId":"100","severity":1,"message":"122","line":1,"column":8,"nodeType":"102","messageId":"103","endLine":1,"endColumn":16},{"ruleId":"100","severity":1,"message":"123","line":49,"column":13,"nodeType":"102","messageId":"103","endLine":49,"endColumn":17},{"ruleId":"110","severity":1,"message":"111","line":232,"column":33,"nodeType":"112","messageId":"113","endLine":232,"endColumn":35},{"ruleId":"110","severity":1,"message":"121","line":518,"column":50,"nodeType":"112","messageId":"113","endLine":518,"endColumn":52},{"ruleId":"110","severity":1,"message":"111","line":522,"column":135,"nodeType":"112","messageId":"113","endLine":522,"endColumn":137},{"ruleId":"100","severity":1,"message":"124","line":585,"column":13,"nodeType":"102","messageId":"103","endLine":585,"endColumn":29},{"ruleId":"110","severity":1,"message":"111","line":628,"column":34,"nodeType":"112","messageId":"113","endLine":628,"endColumn":36},{"ruleId":"110","severity":1,"message":"121","line":654,"column":43,"nodeType":"112","messageId":"113","endLine":654,"endColumn":45},{"ruleId":"110","severity":1,"message":"121","line":655,"column":40,"nodeType":"112","messageId":"113","endLine":655,"endColumn":42},{"ruleId":"100","severity":1,"message":"125","line":668,"column":17,"nodeType":"102","messageId":"103","endLine":668,"endColumn":42},{"ruleId":"100","severity":1,"message":"126","line":669,"column":17,"nodeType":"102","messageId":"103","endLine":669,"endColumn":48},{"ruleId":"110","severity":1,"message":"121","line":671,"column":39,"nodeType":"112","messageId":"113","endLine":671,"endColumn":41},{"ruleId":"110","severity":1,"message":"121","line":674,"column":44,"nodeType":"112","messageId":"113","endLine":674,"endColumn":46},{"ruleId":"110","severity":1,"message":"121","line":788,"column":76,"nodeType":"112","messageId":"113","endLine":788,"endColumn":78},{"ruleId":"104","severity":1,"message":"108","line":817,"column":56,"nodeType":"106","messageId":"109","endLine":817,"endColumn":58},{"ruleId":"110","severity":1,"message":"111","line":818,"column":109,"nodeType":"112","messageId":"113","endLine":818,"endColumn":111},{"ruleId":"110","severity":1,"message":"121","line":819,"column":40,"nodeType":"112","messageId":"113","endLine":819,"endColumn":42},{"ruleId":"110","severity":1,"message":"121","line":822,"column":40,"nodeType":"112","messageId":"113","endLine":822,"endColumn":42},{"ruleId":"110","severity":1,"message":"121","line":829,"column":23,"nodeType":"112","messageId":"113","endLine":829,"endColumn":25},{"ruleId":"100","severity":1,"message":"122","line":1,"column":8,"nodeType":"102","messageId":"103","endLine":1,"endColumn":16},{"ruleId":"127","severity":1,"message":"128","line":1,"column":1,"nodeType":"129","endLine":214,"endColumn":2},{"ruleId":"130","severity":1,"message":"131","line":127,"column":13,"nodeType":"102","messageId":"132","endLine":127,"endColumn":21},{"ruleId":"133","severity":1,"message":"134","line":213,"column":12,"nodeType":"135","messageId":"136","endLine":213,"endColumn":43},"no-native-reassign",["137"],"no-negated-in-lhs",["138"],"@typescript-eslint/no-unused-vars","'escapeJSON' is defined but never used.","Identifier","unusedVar","array-callback-return","Array.prototype.map() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","Array.prototype.map() expects a return value from arrow function.","expectedInside","eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","@typescript-eslint/no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","react/no-direct-mutation-state","Do not mutate state directly. Use setState().","MemberExpression","Expected '===' and instead saw '=='.","'DrawTool' is defined but never used.","'that' is assigned a value but never used.","'proportionsOnOld' is assigned a value but never used.","'ImageProcessingColorCheck' is assigned a value but never used.","'checkChangeToCropPathProcessing' is assigned a value but never used.","import/no-anonymous-default-export","Unexpected default export of anonymous function","ExportDefaultDeclaration","@typescript-eslint/no-redeclare","'generate' is already defined.","redeclared","no-new-func","The Function constructor is eval.","NewExpression","noFunctionConstructor","no-global-assign","no-unsafe-negation"]