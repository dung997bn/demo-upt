[{"D:\\Project\\react\\demo-upt\\src\\index.tsx":"1","D:\\Project\\react\\demo-upt\\src\\App.tsx":"2","D:\\Project\\react\\demo-upt\\src\\data\\datadb.ts":"3","D:\\Project\\react\\demo-upt\\src\\Containers\\DrawToolComponent.tsx":"4","D:\\Project\\react\\demo-upt\\src\\Drawtool\\draw-tool\\DrawTool.ts":"5","D:\\Project\\react\\demo-upt\\src\\Drawtool\\draw-tool\\DrawHistory.ts":"6","D:\\Project\\react\\demo-upt\\src\\Drawtool\\draw-tool\\Sides.ts":"7","D:\\Project\\react\\demo-upt\\src\\Drawtool\\utils\\escapeJSON.ts":"8","D:\\Project\\react\\demo-upt\\src\\Drawtool\\utils\\errors.ts":"9","D:\\Project\\react\\demo-upt\\src\\Drawtool\\draw-tool\\Side.ts":"10","D:\\Project\\react\\demo-upt\\src\\Drawtool\\draw-tool\\Items.ts":"11","D:\\Project\\react\\demo-upt\\src\\Drawtool\\draw-tool\\Layers.ts":"12","D:\\Project\\react\\demo-upt\\src\\Drawtool\\utils\\colorPicker.ts":"13","D:\\Project\\react\\demo-upt\\src\\Drawtool\\utils\\clip.ts":"14","D:\\Project\\react\\demo-upt\\src\\Drawtool\\draw-tool\\Item.ts":"15","D:\\Project\\react\\demo-upt\\src\\Drawtool\\utils\\custom-filter\\changeToCropPathProcessing.ts":"16","D:\\Project\\react\\demo-upt\\src\\Drawtool\\utils\\custom-filter\\imageChangeColorAll.ts":"17","D:\\Project\\react\\demo-upt\\src\\Drawtool\\utils\\custom-filter\\imageProcessingColor.ts":"18","D:\\Project\\react\\demo-upt\\src\\Drawtool\\utils\\custom-filter\\removeColor.ts":"19"},{"size":230,"mtime":1607910893070,"results":"20","hashOfConfig":"21"},{"size":18960,"mtime":1608602076108,"results":"22","hashOfConfig":"21"},{"size":685142,"mtime":1608602076113,"results":"23","hashOfConfig":"21"},{"size":580,"mtime":1607910893065,"results":"24","hashOfConfig":"21"},{"size":8149,"mtime":1608625452558,"results":"25","hashOfConfig":"21"},{"size":2457,"mtime":1608180535113,"results":"26","hashOfConfig":"21"},{"size":1379,"mtime":1607910893067,"results":"27","hashOfConfig":"21"},{"size":202,"mtime":1607910893069,"results":"28","hashOfConfig":"21"},{"size":331,"mtime":1607910893069,"results":"29","hashOfConfig":"21"},{"size":81800,"mtime":1608625052147,"results":"30","hashOfConfig":"21"},{"size":313,"mtime":1607910893066,"results":"31","hashOfConfig":"21"},{"size":6691,"mtime":1607910893066,"results":"32","hashOfConfig":"21"},{"size":3427,"mtime":1608624763797,"results":"33","hashOfConfig":"21"},{"size":8129,"mtime":1607910893069,"results":"34","hashOfConfig":"21"},{"size":1588,"mtime":1607910893066,"results":"35","hashOfConfig":"21"},{"size":2437,"mtime":1608256572447,"results":"36","hashOfConfig":"21"},{"size":1620,"mtime":1608256572447,"results":"37","hashOfConfig":"21"},{"size":7622,"mtime":1608256572447,"results":"38","hashOfConfig":"21"},{"size":1949,"mtime":1608256572447,"results":"39","hashOfConfig":"21"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},"1lszy92",{"filePath":"43","messages":"44","errorCount":0,"warningCount":35,"fixableErrorCount":0,"fixableWarningCount":0,"source":"45","usedDeprecatedRules":"42"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50","usedDeprecatedRules":"42"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53","usedDeprecatedRules":"42"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":26,"fixableErrorCount":0,"fixableWarningCount":0,"source":"64","usedDeprecatedRules":"42"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"69","messages":"70","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"71","usedDeprecatedRules":"42"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"74","usedDeprecatedRules":"42"},{"filePath":"75","messages":"76","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"77"},{"filePath":"78","messages":"79","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"80","usedDeprecatedRules":"42"},{"filePath":"81","messages":"82","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"83","usedDeprecatedRules":"42"},{"filePath":"84","messages":"85","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"86","usedDeprecatedRules":"42"},{"filePath":"87","messages":"88","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"89","usedDeprecatedRules":"42"},"D:\\Project\\react\\demo-upt\\src\\index.tsx",[],["90","91"],"D:\\Project\\react\\demo-upt\\src\\App.tsx",["92","93","94","95","96","97","98","99","100","101","102","103","104","105","106","107","108","109","110","111","112","113","114","115","116","117","118","119","120","121","122","123","124","125","126"],"import React, { Component, Fragment } from 'react';\r\nimport './App.css';\r\nimport DrawToolComponent from './Containers/DrawToolComponent';\r\nimport DrawTool from './Drawtool/draw-tool/DrawTool';\r\nimport { dataDesign, dataObj, stickerCategories, detailDesign } from './data/datadb'\r\ninterface Props { }\r\n\r\ninterface State {\r\n  dataObj: any\r\n};\r\n\r\nclass App extends Component<Props, State> {\r\n  state: State = {\r\n    dataObj: {}\r\n  };\r\n\r\n  constructor(props: Props) {\r\n\r\n    super(props)\r\n\r\n    this.loadToolBar = this.loadToolBar.bind(this)\r\n    this.showDesign = this.showDesign.bind(this)\r\n    this.applyDesign = this.applyDesign.bind(this)\r\n    this.state.dataObj = dataObj.colors\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.loadProduct()\r\n  }\r\n\r\n  loadToolBar() {\r\n    return <Fragment>\r\n      <h1>ToolBar</h1>\r\n      <button onClick={() => this.showDesign()}>Show Design</button>\r\n      <button onClick={() => this.applyDesign()}>Apply Design</button>\r\n    </Fragment>\r\n  }\r\n\r\n  applyDesign() {\r\n    console.log(detailDesign);\r\n    let canvasData = detailDesign.canvas\r\n\r\n    var sizePayload = DrawTool.capacity_uploadingAllImage;\r\n    for (var i = 0; i < canvasData.objects.length; i++) {\r\n      if (canvasData.objects[i].type == \"image\") {\r\n        var infoImage = canvasData.objects[i];\r\n        var xhr = new XMLHttpRequest();\r\n        xhr.open(\"HEAD\", infoImage.src!, true); // Notice \"HEAD\" instead of \"GET\",\r\n        xhr.onreadystatechange = function () {\r\n          if (this.readyState == this.DONE) {\r\n            var fileSizeGet = parseInt(this.getResponseHeader(\"Content-Length\")!);\r\n            if (fileSizeGet < 0) fileSizeGet = 0;\r\n            if (!isNaN(fileSizeGet)) {\r\n              sizePayload += fileSizeGet;\r\n            }\r\n          }\r\n        };\r\n        xhr.send();\r\n      }\r\n    }\r\n    setTimeout(() => {\r\n      if (sizePayload > 31457280) {\r\n        // swal(\"お知らせ\", \"トータルで30mb以上のファイルをアップロードできません。\", \"warning\");\r\n        canvasData.objects = canvasData.objects.filter(item => (item.type != \"image\"));\r\n        canvasData.objects_print = canvasData.objects_print.filter(item => (item.type != \"image\"));\r\n      }\r\n      {\r\n        var jsonCompress = JSON.parse(DrawTool.sides.selected.toJSON());\r\n        let old_work_area = {\r\n          size: DrawTool.sides.selected.getOccupiedAreaSize(),\r\n          factor: {\r\n            x: DrawTool.sides.selected.getBorder().pixel.width,\r\n            y: DrawTool.sides.selected.getBorder().pixel.height\r\n          },\r\n          defaultWorkspace: DrawTool.sides.selected.defaultWorkspaceSize,\r\n          oldBorder: DrawTool.sides.selected.FabricBorder,\r\n        }\r\n        let old_work_area1 = JSON.parse(JSON.stringify(old_work_area));\r\n\r\n        var dataActionValue = 0;\r\n        for (var i = 0; i < DrawTool.sides.selected.items._collection.length; i++) {\r\n          let itemImage = DrawTool.sides.selected.items._collection[i];\r\n          if (itemImage.type && itemImage.sizeImage) {\r\n            if (itemImage.type == \"image\") {\r\n              dataActionValue += itemImage.sizeImage;\r\n            }\r\n          }\r\n        }\r\n\r\n        // store.dispatch(actions.updateCapacityUploading(0 - dataActionValue));\r\n        for (var i = 0; i < canvasData.objects.length; i++) {\r\n          if (DrawTool.embroider_able) {\r\n            jsonCompress.canvas.objects.push(canvasData.objects[i]);\r\n          }\r\n          else {\r\n            if (canvasData.objects[i].pathIndex) {\r\n              if (canvasData.objects[i].pathIndex != 1)\r\n                jsonCompress.canvas.objects.push(canvasData.objects[i]);\r\n            }\r\n            else\r\n              jsonCompress.canvas.objects.push(canvasData.objects[i]);\r\n          }\r\n\r\n        }\r\n        if (DrawTool.embroider_able) {\r\n          if ((canvasData.objects_embroidery) && (canvasData.objects_embroidery.length)) {\r\n            for (var i = 0; i < canvasData.objects_embroidery.length; i++) {\r\n              if ((canvasData.objects[i].pathIndex) && (canvasData.objects[i].pathIndex == 1))\r\n                jsonCompress.canvas.objects_embroidery.push(canvasData.objects_embroidery[i]);\r\n            }\r\n          }\r\n        }\r\n        else\r\n          if (DrawTool.modeToolDraw == DrawTool.modeSetup.LASER) {\r\n            if ((canvasData.objects_special_draw) && (canvasData.objects_special_draw.length)) {\r\n              for (var i = 0; i < canvasData.objects_special_draw.length; i++) {\r\n                if ((canvasData.objects[i].pathIndex) && (canvasData.objects[i].pathIndex == DrawTool.modeSetup.LASER))\r\n                  jsonCompress.canvas.objects_special_draw.push(canvasData.objects_special_draw[i]);\r\n              }\r\n            }\r\n          }\r\n\r\n        if ((canvasData.objects_print) && (canvasData.objects_print.length)) {\r\n          for (var i = 0; i < canvasData.objects_print.length; i++) {\r\n            jsonCompress.canvas.objects_print.push(canvasData.objects_print[i]);\r\n          }\r\n        }\r\n\r\n        for (var i = 0; i < jsonCompress.canvas.objects.length; i++) {\r\n          if (jsonCompress.canvas.objects[i].type == \"image\") {\r\n            jsonCompress.canvas.objects[i].width *= jsonCompress.canvas.objects[i].scaleX;\r\n            jsonCompress.canvas.objects[i].height *= jsonCompress.canvas.objects[i].scaleY;\r\n            jsonCompress.canvas.objects[i].scaleX = 1;\r\n            jsonCompress.canvas.objects[i].scaleY = 1;\r\n          }\r\n        }\r\n\r\n        for (var i = 0; i < jsonCompress.canvas.objects_print.length; i++) {\r\n          if (jsonCompress.canvas.objects_print[i].type == \"image\") {\r\n            jsonCompress.canvas.objects_print[i].width *= jsonCompress.canvas.objects_print[i].scaleX;\r\n            jsonCompress.canvas.objects_print[i].height *= jsonCompress.canvas.objects_print[i].scaleY;\r\n            jsonCompress.canvas.objects_print[i].scaleX = 1;\r\n            jsonCompress.canvas.objects_print[i].scaleY = 1;\r\n          }\r\n        }\r\n        DrawTool.sides.selected.addItemLayer(JSON.stringify(jsonCompress), old_work_area1);\r\n\r\n        setTimeout(() => {\r\n          DrawTool.sides.selected.setOverlayBorder(\"\", true);\r\n\r\n          for (var i = 0; i < DrawTool.sides.selected.items._collection.length; i++) {\r\n            if (DrawTool.sides.selected.items._collection[i].type == \"image\") {\r\n              var infoImage = DrawTool.sides.selected.items._collection[i];\r\n              var xhr = new XMLHttpRequest();\r\n              xhr.open(\"HEAD\", infoImage.src, true); // Notice \"HEAD\" instead of \"GET\",\r\n              xhr.onreadystatechange = function () {\r\n                if (this.readyState == this.DONE) {\r\n\r\n                  var fileSizeGet = parseInt(this.getResponseHeader(\"Content-Length\")!);\r\n                  if (fileSizeGet < 0) fileSizeGet = 0;\r\n                  if (!isNaN(fileSizeGet)) {\r\n                    DrawTool.sides.selected.items._collection.forEach((element: any) => {\r\n                      if (element.src == this.responseURL) {\r\n                        element.sizeImage = fileSizeGet;\r\n                      }\r\n                    });\r\n                    // store.dispatch(actions.updateCapacityUploading(fileSizeGet));\r\n                  }\r\n                }\r\n              };\r\n              xhr.send();\r\n            }\r\n          }\r\n\r\n          if (DrawTool.embroider_able) {\r\n            // store.dispatch(actions.unselectItem())\r\n            DrawTool.sides.selected.FabricCanvas.deactivateAll();\r\n            DrawTool.sides.selected.FabricCanvas.renderAll();\r\n            DrawTool.sides.select(DrawTool.sides.selected.id);\r\n            DrawTool.sides.selected.panning = false;\r\n            DrawTool.sides.selected.drawingMode(false);\r\n            DrawTool.setEmbroidery(DrawTool.is_embroidery);\r\n          }\r\n        }, 500);\r\n      }\r\n    }, 500);\r\n\r\n  }\r\n\r\n  showDesign() {\r\n    console.log(dataDesign);\r\n\r\n    if (dataDesign.product.colors.length) {\r\n\r\n      if (dataDesign.category_id === 62) {\r\n        DrawTool.is_nail = true;\r\n      }\r\n      else {\r\n        DrawTool.is_nail = false;\r\n      }\r\n      if (!dataDesign.product.Product.embroider_able)\r\n        dataDesign.product.Product.embroider_able = 0;\r\n      if (1 === dataDesign.product.Product.embroider_able)\r\n        DrawTool.embroider_able = true;\r\n      else\r\n        DrawTool.embroider_able = false;\r\n      if ((!!dataDesign.product.Product.special_draw) && (dataDesign.product.Product.special_draw >= DrawTool.modeSetup.LASER)) {\r\n        DrawTool.modeToolDraw = dataDesign.product.Product.special_draw;\r\n      }\r\n      else {\r\n        if (DrawTool.embroider_able)\r\n          DrawTool.modeToolDraw = DrawTool.modeSetup.EMBROIDER;\r\n        else\r\n          DrawTool.modeToolDraw = -1;\r\n      }\r\n\r\n      const color = dataDesign.product.colors.find((c: any) => {\r\n        return c.ProductColor.id === dataDesign.selected_color_id;\r\n      });\r\n      console.log(color);\r\n\r\n      const data = color.sides.map((side: any) => {\r\n        return JSON.parse(side.ProductColorSide.content);\r\n      });\r\n\r\n      let overlayImages = \"\";\r\n      if (color.sides.length === 1) {\r\n        overlayImages = color.sides.map((side: any) => {\r\n          if (side.ProductColorSide.overlay_image) {\r\n            return side.ProductColorSide.overlay_image;\r\n          }\r\n        });\r\n      }\r\n      let currentCategory = dataDesign.category_id;\r\n\r\n\r\n      DrawTool.importJSON(JSON.stringify(data)).then(() => {\r\n        for (var i = 0; i < data.length; i++) {\r\n          if (data[i].border_special) {\r\n            DrawTool.sides.selected.saveBoder(data[i].border, data[i].border_special);\r\n          }\r\n        }\r\n        DrawTool.sides._collection.forEach((side, index) => {\r\n          // store.dispatch(actions.updateProcessBar(0.8))\r\n          if (dataDesign.sides[side.id]) {\r\n            console.log(JSON.parse(dataDesign.sides[side.id]));\r\n\r\n            //console.log(\"delete fun tion by cuongLV11  LOAD_PRODUCT_WITH_DESIGN\");\r\n            //DrawTool.updateEmbroideryBorder(JSON.parse(action.payload.sides[side.id]).embroiderySaveBorder);\r\n            setTimeout(() => {\r\n              if (dataDesign.sides[side.id].startsWith('http')) {\r\n\r\n                side.items.addImage(`${dataDesign.sides[side.id]}?_`);\r\n                if (data.length === 1 && overlayImages.length > 0 && overlayImages[index] && !DrawTool.is_nail) {\r\n                  DrawTool.sides.selected.overlay = true\r\n                  DrawTool.sides.selected.setOverlayBorder(overlayImages[index]);\r\n                  DrawTool.sides.selected.FabricCanvas._objects.map((item: any) => {\r\n                    if (item.id != \"FabricBorder\") {\r\n                      item.clipTo = null\r\n                    }\r\n                  })\r\n                  DrawTool.sides.selected.FabricCanvas.renderAll();\r\n                }\r\n                // store.dispatch(actions.updateProcessBar(0.99));\r\n                // store.dispatch(product_action.setLoadingData(false));\r\n                // store.dispatch(actions.setLoadingProcess(false));\r\n                // store.dispatch(actions.setLoading(false));\r\n                DrawTool.setLayerSetup(-1);\r\n              } else {\r\n                side.fromJSON(dataDesign.sides[side.id], () => {\r\n                  // store.dispatch(product_action.setLoadingData(false));\r\n                  if (data.length === 1 && overlayImages.length > 0 && overlayImages[index] && !DrawTool.is_nail) {\r\n                    DrawTool.sides.selected.overlay = true\r\n                    DrawTool.sides.selected.FabricCanvas._objects.map((item: any) => {\r\n                      if (item.id != \"FabricBorder\") {\r\n                        item.clipTo = null\r\n                      }\r\n                      DrawTool.sides.selected.setOverlayBorder(overlayImages[index]);\r\n                    })\r\n                    DrawTool.sides.selected.FabricCanvas.renderAll();\r\n                  }\r\n\r\n                  setTimeout(() => {\r\n                    // store.dispatch(actions.updateLayers({\r\n                    //   layers: DrawTool.sides.selected.layers.update().reverse(),\r\n                    //   side: DrawTool.sides.selected.id,\r\n                    // }));\r\n                    // store.dispatch(actions.setActiveTool('pointer'));\r\n                    // store.dispatch(actions.updateProcessBar(0.99));\r\n                    // store.dispatch(actions.setLoadingProcess(false));\r\n                    // store.dispatch(actions.setLoading(false));\r\n                    DrawTool.setLayerSetup(-1);\r\n                  }, 2000);\r\n                }, true);\r\n              }\r\n            }, 1000)\r\n          }\r\n        });\r\n        DrawTool.trigger('product:load', {});\r\n\r\n        setTimeout(() => {\r\n          if (DrawTool.modeSetup.LASER == DrawTool.modeToolDraw) {\r\n            // store.dispatch(actions.updateBorder());\r\n          }\r\n        }, 3500);\r\n        setTimeout(() => {\r\n\r\n\r\n          DrawTool.sides._collection.forEach(function (side) {\r\n            console.log(side.items._collection);\r\n            for (var i = 0; i < side.items._collection.length; i++) {\r\n              if (side.items._collection[i].type == \"image\") {\r\n                var infoImage = side.items._collection[i];\r\n                var xhr = new XMLHttpRequest();\r\n                xhr.open(\"HEAD\", infoImage.src, true); // Notice \"HEAD\" instead of \"GET\",\r\n                xhr.onreadystatechange = function () {\r\n                  if (this.readyState == this.DONE) {\r\n                    //console.log(\"get alll info .................................... checkk allcd  \");\r\n                    //console.log(this);\r\n                    var fileSizeGet = parseInt(this.getResponseHeader(\"Content-Length\")!);\r\n                    var dataurl = this.responseURL;\r\n                    if (fileSizeGet < 0) fileSizeGet = 0;\r\n                    //console.log(\"APPLY_TEMPLATE ..........................\");\r\n                    //console.log(fileSizeGet);\r\n                    //console.log(fileSizeGet);\r\n                    if (!isNaN(fileSizeGet)) {\r\n                      DrawTool.sides._collection.forEach(function (sideIn) {\r\n                        sideIn.items._collection.forEach((element: any) => {\r\n                          if (element.src == dataurl) {\r\n                            element.sizeImage = fileSizeGet;\r\n                          }\r\n                        });\r\n                      });\r\n                      // store.dispatch(actions.updateCapacityUploading(fileSizeGet));\r\n                      // console.log(DrawTool.sides.selected.items._collection);\r\n                      //console.log(linkUp);\r\n                    }\r\n                  }\r\n                };\r\n                xhr.send();\r\n              }\r\n            }\r\n\r\n          });\r\n        }, 2100);\r\n      });\r\n\r\n      DrawTool.sides.select(\r\n        JSON.parse(JSON.parse(JSON.stringify(color.sides[0].ProductColorSide.content))).id\r\n      );\r\n    }\r\n  }\r\n\r\n\r\n  loadProduct() {\r\n    // console.log(dataDesign);\r\n\r\n    DrawTool._embroideryPaths = [];\r\n    // if (action.payload.Product && action.payload.colors.length) {\r\n    //   if (action.payload.Product.category_id === 62) {\r\n    //     DrawTool.is_nail = true;\r\n    //     // DrawTool.is_ribbon = false;\r\n    //   }\r\n    //   //  else if(action.payload.Product.category_id === 80){\r\n    //   //   DrawTool.is_ribbon = true;\r\n    //   // }\r\n    //   else {\r\n    //     DrawTool.is_nail = false;\r\n    //     // DrawTool.is_ribbon = false;\r\n    //   }\r\n\r\n\r\n\r\n    let color = this.state.dataObj[0]\r\n\r\n    // console.log(action.payload);\r\n    // if (!action.payload.Product.embroider_able)\r\n    //   action.payload.Product.embroider_able = 0;\r\n    // if (1 == action.payload.Product.embroider_able)\r\n    //   DrawTool.embroider_able = true;\r\n    // else\r\n    //   DrawTool.embroider_able = false;\r\n\r\n\r\n    // if ((action.payload.Product.special_draw) && (action.payload.Product.special_draw >= DrawTool.modeSetup.LASER)) {\r\n    //   DrawTool.modeToolDraw = action.payload.Product.special_draw;\r\n    // }\r\n    // else {\r\n    //   if (DrawTool.embroider_able)\r\n    //     DrawTool.modeToolDraw = DrawTool.modeSetup.EMBROIDER;\r\n    //   else {\r\n    //     if (DrawTool.embroider_able)\r\n    //       DrawTool.modeToolDraw = DrawTool.modeSetup.EMBROIDER;\r\n    //     else\r\n    //       DrawTool.modeToolDraw = -1;\r\n    //   }\r\n    // }\r\n\r\n    const data = color.sides.map((side: any) => {\r\n\r\n      let content = side.ProductColorSide.content\r\n\r\n      return content;//JSON.parse(JSON.parse(escapeJSON(side.ProductColorSide.content)));\r\n    });\r\n\r\n    // console.log(data);\r\n\r\n\r\n    // store.dispatch(actions.updateProcessBar(0.7))\r\n    let overlayImages = \"\";\r\n    if (color.sides.length === 1) {\r\n      overlayImages = color.sides.map((side: any) => {\r\n        if (side.ProductColorSide.overlay_image) {\r\n          return side.ProductColorSide.overlay_image;\r\n        }\r\n      });\r\n    }\r\n\r\n    console.log(data);\r\n\r\n    DrawTool.importJSON(JSON.stringify(data)).then(() => {\r\n      DrawTool.sides.select(color.sides[1].ProductColorSide.content.id);\r\n      // store.dispatch(product_action.setLoadingData(false));\r\n\r\n      for (var i = 0; i < data.length; i++) {\r\n        if (data[i].border_special) {\r\n          DrawTool.sides.selected.saveBoder(data[i].border, data[i].border_special);\r\n        }\r\n      }\r\n      // if (data.length === 1 && overlayImages.length > 0 && overlayImages[0] && !DrawTool.is_nail) {\r\n      //   DrawTool.sides.selected.overlay = true\r\n      //   DrawTool.sides.selected.setOverlayBorder(overlayImages[0]);\r\n      //   DrawTool.sides.selected.FabricCanvas._objects.map((item: any) => {\r\n      //     if (item.id != \"FabricBorder\") {\r\n      //       item.clipTo = null\r\n      //     }\r\n      //   });\r\n      //   DrawTool.sides.selected.FabricCanvas.renderAll();\r\n      // }\r\n      DrawTool.sides.selected.FabricCanvas.renderAll();\r\n      // store.dispatch(actions.updateProcessBar(0.99))\r\n      setTimeout(() => {\r\n\r\n        // store.dispatch(actions.resetDefaultParas(false));\r\n        DrawTool.sides.selected.setSelectableForDesign();\r\n        // store.dispatch(product_action.setLoadingData(false));\r\n        // store.dispatch(actions.setLoading(false));\r\n        // store.dispatch(actions.updateProcessBar(100));\r\n        // store.dispatch(actions.setLoadingProcess(false));\r\n        DrawTool.setLayerSetup(-1);\r\n        // if (DrawTool.modeSetup.LASER == DrawTool.modeToolDraw) {\r\n        //   store.dispatch(actions.updateBorder());\r\n        // }\r\n      }, 2000)\r\n      DrawTool.trigger('product:load', {});\r\n    });\r\n  }\r\n\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"App\" >\r\n        <div className=\"app-container\">\r\n\r\n          <div className=\"app-container-inner\">\r\n            <div className=\"toolbar\">\r\n              {this.loadToolBar()}\r\n            </div>\r\n            <DrawToolComponent colors={this.state.dataObj}></DrawToolComponent>\r\n          </div>\r\n        </div>\r\n\r\n      </div >\r\n    );\r\n  }\r\n\r\n}\r\n\r\nexport default App;\r\n","D:\\Project\\react\\demo-upt\\src\\data\\datadb.ts",[],"D:\\Project\\react\\demo-upt\\src\\Containers\\DrawToolComponent.tsx",["127"],"import { Component, ReactNode } from \"react\";\r\nimport DrawTool from \"../Drawtool/draw-tool/DrawTool\";\r\n\r\ninterface Props {\r\n    colors:any\r\n }\r\n\r\ninterface State {\r\n    node: ReactNode\r\n};\r\n\r\nclass DrawToolComponent extends Component<Props, State>{\r\n    state: State = {\r\n        node: null\r\n    };\r\n\r\n    componentDidMount() {\r\n        DrawTool.initialize(this.state.node as HTMLElement, {});\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className=\"draw-tool\" ref={(node) => { this.state.node = node}} />\r\n        );\r\n    }\r\n}\r\n\r\nexport default DrawToolComponent;","D:\\Project\\react\\demo-upt\\src\\Drawtool\\draw-tool\\DrawTool.ts",["128","129"],"import errors from \"../utils/errors\";\r\nimport escapeJSON from \"../utils/escapeJSON\";\r\nimport DrawHistory from \"./DrawHistory\";\r\nimport Side from \"./Side\";\r\nimport Sides from \"./Sides\";\r\n\r\nimport '../utils/custom-filter/changeToCropPathProcessing';\r\nimport '../utils/custom-filter/imageChangeColorAll';\r\nimport '../utils/custom-filter/imageProcessingColor';\r\nimport '../utils/custom-filter/removeColor';\r\n\r\nlet DrawTool = {\r\n    editable: false,\r\n    container: {\r\n        target: document.body,\r\n        size: {\r\n            width: 0,\r\n            height: 0\r\n        }\r\n    },\r\n    modeSetup: {\r\n        NOMAL: -1,\r\n        EMBROIDER: 1,\r\n        LASER: 3,\r\n        MASK_LASER: 4,\r\n        TAP_RIBBON: 5, //Type1(white, black, red, blue )   ?Tape Editor\r\n        TAP_RIBBON_2EDIT: 6, //Type2(black, red, blue, gold, silver) ?Ribbon Editor\r\n        DRAW3D: 20\r\n    },\r\n    uploadImageState: [],\r\n    gridStep: 10,\r\n    grid: {\r\n        color: 'rgba(150, 150, 150, 0.1)',\r\n        strokeWidth: 1\r\n    },\r\n    border: {\r\n        color: 'rgba(100,200,200,1)',\r\n        strokeWidth: 1,\r\n        backgroundColor: 'rgba(150, 150, 150, 0.1)',\r\n        strokeDashArray: [0, 0],\r\n    },\r\n    newColorPicked: null,\r\n\r\n    _callbacks: {} as any,\r\n\r\n    sides: new Sides(),\r\n    history: new DrawHistory(),\r\n    _evented: true,\r\n\r\n    __data: {} as any,\r\n    modeSpecialDrawEnable: -1,\r\n    is_embroidery: false,\r\n    embroider_able: false,\r\n    capacity_uploadingAllImage: 0,\r\n    _originalJson: {},\r\n\r\n    _designBorders: [] as any[],\r\n    _embroideryPaths: [] as any,\r\n    is_choosing: false,\r\n\r\n    is_nail: false,\r\n\r\n    is_mobile: false,\r\n    is_data: [],\r\n    is_sp_product: false,\r\n    is_area_embroider: false,\r\n    fonts: null,\r\n    rasterizedText: null,\r\n    modeToolDraw: -1 as number,\r\n    //func\r\n    initialize(target: HTMLElement, size: any) {\r\n        if (!(target instanceof HTMLElement)) {\r\n            throw (new Error(JSON.stringify({ error: errors.HTMLElementUndefined })));\r\n        }\r\n\r\n        // let _target = window.hasOwnProperty('jQuery') && target instanceof jQuery ? target[0] : target;\r\n        let _target = target;\r\n\r\n        let _size = size || {};\r\n\r\n        this.container = {\r\n            target: _target,\r\n            size: _size\r\n        };\r\n\r\n        this.container.target.textContent = '';\r\n        this.container.target.style.position = 'relative';\r\n\r\n        // this.sides = new Sides();\r\n\r\n        this.history = new DrawHistory();\r\n    },\r\n    setEmbroidery(val = false) {\r\n        this.is_embroidery = val;\r\n        if (!val) {\r\n            this.sides.selected._selected_path_index = -1;\r\n            this.modeSpecialDrawEnable = -1;\r\n        } else {\r\n            this.sides.selected._selected_path_index = 1;\r\n            this.modeSpecialDrawEnable = 1;\r\n        }\r\n        this.sides._collection.map((side) => {\r\n            side.setSelectableForDesign();\r\n        });\r\n\r\n        this.sides.selected.FabricCanvas.renderAll();\r\n    },\r\n\r\n    rec2path(rec: any) {\r\n        return `\"M${rec.left} ${rec.top} h ${rec.width} v ${rec.height} h -${rec.width} Z\"`;\r\n    },\r\n\r\n    recs2paths(recs: any) {\r\n        recs.map((r: any) => {\r\n            r.right = r.left + r.width;\r\n            r.bottom = r.top + r.height;\r\n        });\r\n\r\n        let lefts = recs.map((r: any) => { return r.left });\r\n        let rights = recs.map((r: any) => { return r.right });\r\n        let tops = recs.map((r: any) => { return r.top });\r\n        let bottoms = recs.map((r: any) => { return r.bottom });\r\n        let minLeft = Math.min(...lefts);\r\n        let maxRight = Math.max(...rights);\r\n        let minTop = Math.min(...tops);\r\n        let maxBottom = Math.max(...bottoms);\r\n        let width = maxRight - minLeft;\r\n        let height = maxBottom - minTop;\r\n\r\n        let paths = `\"M${minLeft} ${minTop} h${0.01} v${0.01} h-${0.01} v-${0.01} M${maxRight} ${maxBottom} h -${0.01} v -${0.01} h ${0.01} v ${0.01}\"`;\r\n        Array.prototype.forEach.call(recs, (item, i) => {\r\n            paths += \",\" + this.rec2path(item);\r\n        });\r\n\r\n        let cmpixel = `{\"left\": ${minLeft},\"top\": ${minTop},\"width\": ${width},\"height\": ${height}}`;\r\n        return `{\"paths\": [${paths}], \"cm\": ${cmpixel}, \"pixel\": ${cmpixel}}`;\r\n    },\r\n    setLayerSetup(val = 0) {\r\n        this.modeSpecialDrawEnable = val;\r\n        if (this.modeSpecialDrawEnable < 1) {\r\n            this.sides.selected._selected_path_index = -1;\r\n            this.is_embroidery = false;\r\n        } else {\r\n            this.sides.selected._selected_path_index = this.modeSpecialDrawEnable;\r\n            //if(this.modeSpecialDrawEnable==1) this.is_embroidery = true;\r\n        }\r\n        this.sides._collection.map((side: Side) => {\r\n            side.setSelectableForDesign();\r\n            return side\r\n        });\r\n        this.sides.selected.FabricCanvas.renderAll();\r\n    },\r\n\r\n\r\n    importJSON(json: any, initialZoom?: Number, proportions?: Number | 0.5) {\r\n        this._originalJson = json;\r\n        let oldSideSizes: any = {};\r\n\r\n        Array.prototype.forEach.call(this.sides._collection, (side: Side) => {\r\n            if (side.layers.list.length)\r\n                oldSideSizes[side.id] = side.getOccupiedAreaSize();\r\n        });\r\n\r\n        if (this.sides._collection.length) {\r\n            this.sides.empty();\r\n            this.history.history = {};\r\n        }\r\n        let that = this\r\n\r\n        let data = JSON.parse(escapeJSON(json));\r\n        DrawTool.is_data = JSON.parse(escapeJSON(json));\r\n        let promises = data.map((side: Side) => {\r\n            let _side = this.sides.addSide(side.id);\r\n            let imageUrl = side.imageUrl;\r\n\r\n            if (imageUrl.indexOf('http') === 0)\r\n                imageUrl += '?_';\r\n\r\n            var border = { sideId: side.id, border: [side.border.cm, side.border.pixel] };\r\n            this._designBorders.push(border);\r\n\r\n            return _side.setImage(imageUrl, side.size.cm, proportions, side.border.cm);\r\n        });\r\n\r\n        var spProductObj = data.find((dt: any) => {\r\n            return dt.id === '1';\r\n        });\r\n\r\n        if (spProductObj.border.cm.width === 120) {\r\n            this.is_sp_product = true;\r\n        } else {\r\n            this.is_sp_product = false;\r\n        }\r\n\r\n        return new Promise<any>((resolve, reject) => {\r\n\r\n            Promise.all(promises).then(values => {\r\n                values.map((d: any, index) => {\r\n                    let _side = that.sides.getSide(d.side.id);\r\n\r\n                    _side.defaultWorkspaceSize = data[index].border.pixel;\r\n\r\n                    _side.setBorder(data[index].border);\r\n\r\n                    if (initialZoom) {\r\n                        _side.zoomToVal(initialZoom);\r\n                    }\r\n                    if ((DrawTool.modeToolDraw === DrawTool.modeSetup.TAP_RIBBON) || (DrawTool.modeToolDraw === DrawTool.modeSetup.TAP_RIBBON_2EDIT)) {\r\n                        _side.zoomToVal(1.6);\r\n                    }\r\n\r\n                    setTimeout(() => {\r\n                        if (this.__data[_side.id]) {\r\n                            if (oldSideSizes[_side.id] && !this.is_choosing) {\r\n                                _side.fromJSON(this.__data[_side.id], () => { }, false, oldSideSizes[_side.id]);\r\n                                this.is_choosing = false;\r\n                            }\r\n                            else\r\n                                _side.fromJSON(this.__data[_side.id]);\r\n                        }\r\n\r\n                        _side.FabricCanvas.renderAll.bind(_side.FabricCanvas);\r\n                    });\r\n                    return d\r\n                });\r\n\r\n                resolve(null);\r\n            });\r\n        });\r\n    },\r\n\r\n\r\n    trigger(event: String, data?: any) {\r\n        if (!this._evented) {\r\n            return false;\r\n        }\r\n\r\n        if (event === 'history:update') {\r\n            this.history.pushState(data.side.id);\r\n            this.sides.getSide(data.side.id).layers.update();\r\n        }\r\n\r\n        if (this._callbacks.hasOwnProperty(event)) {\r\n            this._callbacks.event.forEach((cb: any) => cb(JSON.stringify(data)));\r\n        }\r\n    },\r\n}\r\n\r\nexport default DrawTool;","D:\\Project\\react\\demo-upt\\src\\Drawtool\\draw-tool\\DrawHistory.ts",[],"D:\\Project\\react\\demo-upt\\src\\Drawtool\\draw-tool\\Sides.ts",[],"D:\\Project\\react\\demo-upt\\src\\Drawtool\\utils\\escapeJSON.ts",[],"D:\\Project\\react\\demo-upt\\src\\Drawtool\\utils\\errors.ts",[],"D:\\Project\\react\\demo-upt\\src\\Drawtool\\draw-tool\\Side.ts",["130","131","132","133","134","135","136","137","138","139","140","141","142","143","144","145","146","147","148","149","150","151","152","153","154","155"],"import DrawTool from \"./DrawTool\";\r\nimport Items from \"./Items\";\r\nimport fabric from 'fabric'\r\nimport Layers from \"./Layers\";\r\nimport escapeJSON from \"../utils/escapeJSON\";\r\nimport clip from \"../utils/clip\";\r\nimport errors from \"../utils/errors\";\r\nimport Item from \"./Item\";\r\nimport colorPicker from \"../utils/colorPicker\";\r\nclass Side {\r\n    id: string\r\n    container: any\r\n    canvas: HTMLCanvasElement\r\n    padding: any\r\n    isZoom: any\r\n    currentPathPosision: any\r\n    _selected_path_index: any\r\n    _changeBorder: any\r\n    border_special: any\r\n    start_boder: any\r\n    nameSide: any\r\n    _panning: any\r\n    is_empty: any\r\n    number_embroider: any\r\n    number_special_draw: any\r\n    number_embroider_sp: any\r\n    number_draw: any\r\n    number_print_draw: any\r\n    overlay: any\r\n    _zoom_zone: any\r\n    imageUrl: any\r\n    overlayImage: any\r\n    _selected_path_indexis_nail: any\r\n    items: any\r\n\r\n    center: any\r\n    FabricCanvas: any\r\n\r\n    FabricBorder: any\r\n    layers: Layers\r\n    border: any\r\n    size: any\r\n    bgOffset: any\r\n    backdrop: any\r\n    _pan_x0: any\r\n    _pan_y0: any\r\n    defaultWorkspaceSize: any\r\n    cmSize: any\r\n    bgProportions: any\r\n    workspaceGrid: any\r\n    _panningDown: boolean\r\n    colorPicker: any\r\n    grid: any\r\n    workspaceRuler: any\r\n    ruler: any\r\n\r\n    constructor(id: string) {\r\n        this.id = id;\r\n\r\n        this.container = document.createElement('div');\r\n\r\n        this.canvas = document.createElement('canvas');\r\n        this.padding = 10;\r\n\r\n        this.isZoom = false;\r\n\r\n        this._selected_path_index = 1;\r\n\r\n        this._changeBorder = false;\r\n\r\n        this.currentPathPosision = null;\r\n        this.border_special = null;\r\n        this.start_boder = {};\r\n        this.nameSide = '';\r\n\r\n        this._panning = false;\r\n\r\n        this.is_empty = true;\r\n        this.number_embroider = 0;\r\n        this.number_special_draw = 0;\r\n        this.number_embroider_sp = {};\r\n        this.number_draw = 0;\r\n        this.number_print_draw = 0;\r\n\r\n        this.overlay = false;\r\n\r\n        this._zoom_zone = false;\r\n\r\n        this.imageUrl = null;\r\n\r\n        this.overlayImage = null;\r\n        this._selected_path_index = -1;\r\n        this._selected_path_indexis_nail = 1;\r\n\r\n        this.container.width = DrawTool.container.size.width || DrawTool.container.target.clientWidth;\r\n        this.container.height = DrawTool.container.size.height || DrawTool.container.target.clientHeight;\r\n        this.container.style.position = 'absolute';\r\n        this.container.style.top = '0';\r\n        this.container.style.left = '0';\r\n\r\n        this.canvas.width = DrawTool.container.size.width || DrawTool.container.target.clientWidth;\r\n        this.canvas.height = DrawTool.container.size.height || DrawTool.container.target.clientHeight;\r\n\r\n        this.container.appendChild(this.canvas);\r\n        DrawTool.container.target.appendChild(this.container);\r\n        this._initFabric();\r\n        this._initEvents();\r\n\r\n        this.items = new Items(this);\r\n\r\n        this.layers = new Layers(this);\r\n\r\n        this.workspaceGrid = null\r\n        this._panningDown = false\r\n\r\n        // this.currentBrush = 'PencilBrush';\r\n\r\n        this.colorPicker = new colorPicker(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    updateSize(size: any) {\r\n\r\n        this.size = size;\r\n\r\n        this.cmSize = this._calculateSize();\r\n\r\n        this.initGrid();\r\n        this.initRuler();\r\n\r\n        if (this.FabricBorder) {\r\n            this.initWorkspaceGrid();\r\n            this.initWorkspaceRuler();\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n * Get\r\n * @return {String}\r\n */\r\n    toJSON() {\r\n        DrawTool.is_data.map((side: Side) => {\r\n            if (side.border_special) {\r\n                var borderEmbroider1 = { sideId: side.id, border: side.border_special, bd: side.border }\r\n                DrawTool._embroideryPaths.push(borderEmbroider1);\r\n\r\n            } else {\r\n                var pathEmbroider = `M${side.border.cm.left} ${side.border.cm.top} h${side.border.cm.width} v${side.border.cm.height} h-${side.border.cm.width} Z`;\r\n                if (DrawTool.embroider_able) {\r\n                    side.border.paths = [pathEmbroider];\r\n                }\r\n                var borderEmbroider2 = { sideId: side.id, border: [{ cm: side.border.cm, paths: side.border.paths, pixel: side.border.pixel, name: \"\" }], bd: side.border };\r\n                DrawTool._embroideryPaths.push(borderEmbroider2);\r\n            }\r\n        });\r\n\r\n        let _formattedSide = {\r\n            id: this.id,\r\n            imageUrl: this.imageUrl,\r\n            size: this.size,\r\n            is_empty: this.is_empty,\r\n            number_embroider: this.number_embroider,\r\n            number_special_draw: this.number_special_draw,\r\n            number_draw: this.number_draw,\r\n            number_embroider_sp: this.number_embroider_sp,\r\n            number_print_draw: this.number_print_draw,\r\n            canvas: this.FabricCanvas.toObject(['brush', 'editable', 'vertical', 'color', 'typeSVG', 'pathIndex', 'fileContent', 'fileContentURL', 'typePaths', 'lastBorder', 'areaEmbroider', 'pathDLaser']),\r\n            fonts: DrawTool.fonts,\r\n            border_special: this.border_special,\r\n            border: null as any,\r\n            factor: null as any,\r\n            about: null as any,\r\n            design_border: null as any\r\n        };\r\n\r\n        var itemOrder = [];\r\n\r\n        for (var i = 0; i < _formattedSide.canvas.objects.length; i++) {\r\n            if (_formattedSide.canvas.objects[i].pathIndex) {\r\n                if (_formattedSide.canvas.objects[i].pathIndex < 1) {\r\n                    itemOrder.push(_formattedSide.canvas.objects[i]);\r\n                }\r\n            }\r\n            else {\r\n                itemOrder.push(_formattedSide.canvas.objects[i]);\r\n            }\r\n        }\r\n\r\n        for (var i = 0; i < _formattedSide.canvas.objects.length; i++) {\r\n            if ((_formattedSide.canvas.objects[i].pathIndex) && (_formattedSide.canvas.objects[i].pathIndex > 0)) {\r\n                itemOrder.push(_formattedSide.canvas.objects[i]);\r\n            }\r\n\r\n        }\r\n        _formattedSide.canvas.objects = itemOrder;\r\n\r\n        _formattedSide.canvas.objects.forEach((item: any, i: number) => {\r\n            item.left = item.left - this.center.x;\r\n            item.top = item.top - this.center.y;\r\n            item.clipTo = null;\r\n            if (!item.type.includes('text') && !!item.fill) {\r\n                item.fill = null\r\n            }\r\n\r\n            if (item.selected) {\r\n                item.selectable = false;\r\n            }\r\n\r\n            if (item.type.includes('text') && DrawTool.rasterizedText) {\r\n                if (DrawTool.rasterizedText![item.uuid]) {\r\n                    let textObject = fabric.fabric.util.object.clone(item);\r\n                    item.visible = false;\r\n\r\n                    textObject.type = 'image';\r\n                    textObject.fill = 'rgb(0,0,0)';\r\n                    textObject.strokeWidth = 0;\r\n                    textObject.crossOrigin = 'anonymous';\r\n                    textObject.src = DrawTool.rasterizedText![item.uuid];\r\n                    textObject.alignX = 'none';\r\n                    textObject.alignY = 'none';\r\n                    textObject.meetOrSlice = 'meet';\r\n                    textObject.filters = [];\r\n                    textObject.resizeFilters = [];\r\n                    textObject.width = textObject.width * textObject.scaleX + textObject.width * textObject.scaleX * 0.1;\r\n                    textObject.height = textObject.height * textObject.scaleY + textObject.height * textObject.scaleY * 0.1;\r\n                    textObject.scaleX = 1;\r\n                    textObject.scaleY = 1;\r\n                    let cos = Math.cos(textObject.angle * Math.PI / 180);\r\n                    let sin = Math.sin(textObject.angle * Math.PI / 180);\r\n\r\n                    textObject.left += textObject.width * textObject.scaleX * 0.05 * cos;\r\n                    textObject.top += textObject.width * textObject.scaleX * 0.05 * sin;\r\n\r\n                    delete textObject['text'];\r\n                    delete textObject['fontSize'];\r\n                    delete textObject['fontWeight'];\r\n                    delete textObject['fontFamily'];\r\n                    delete textObject['fontStyle'];\r\n                    delete textObject['lineHeight'];\r\n                    delete textObject['textDecoration'];\r\n                    delete textObject['textAlign'];\r\n                    delete textObject['textBackgroundColor'];\r\n                    delete textObject['charSpacing'];\r\n                    delete textObject['editable'];\r\n                    delete textObject['vertical'];\r\n                    delete textObject['styles'];\r\n\r\n                    textObject.pathIndex = item.pathIndex;\r\n                    textObject.areaEmbroider = item.areaEmbroider\r\n                    _formattedSide.canvas.objects[i] = textObject;\r\n                    _formattedSide.canvas.objects.push(item);\r\n                }\r\n            }\r\n            if (item.brush) item.pathIndex = -1;\r\n        });\r\n\r\n        _formattedSide.canvas.objects_print = [];\r\n        _formattedSide.canvas.objects_embroidery = [];\r\n        _formattedSide.canvas.objects_special_draw = [];\r\n        _formattedSide.canvas.objects.forEach((item: any, i: number) => {\r\n            if ((item.brush) || (item.pathIndex === -1)) {\r\n                _formattedSide.canvas.objects_print.push(item);\r\n            } else {\r\n\r\n                if ((item.pathIndex) && (item.pathIndex == DrawTool.modeSetup.LASER)) {\r\n                    _formattedSide.border = this.getBorder();\r\n                    item.pathBorderLaser = {\r\n                        size: this.size, border: _formattedSide.border.cm,\r\n                        center: this.center, _pan_x0: this._pan_x0, _pan_y0: this._pan_y0,\r\n                        borderPixel: _formattedSide.border.pixel\r\n                    };\r\n                    _formattedSide.canvas.objects_special_draw.push(item);\r\n                }\r\n                else if ((item.pathIndex) && (item.pathIndex == DrawTool.modeSetup.EMBROIDER)) {\r\n                    _formattedSide.canvas.objects_embroidery.push(item);\r\n                }\r\n                else {\r\n                    _formattedSide.canvas.objects_print.push(item);\r\n                }\r\n            }\r\n        });\r\n\r\n        if (this.backdrop) {\r\n            _formattedSide.imageUrl = this.imageUrl\r\n        }\r\n\r\n        if (this.FabricBorder) {\r\n            _formattedSide.border = this.getBorder();\r\n            _formattedSide.factor = {\r\n                x: this.getBorder().pixel.width / this.defaultWorkspaceSize.width,\r\n                y: this.getBorder().pixel.height / this.defaultWorkspaceSize.height,\r\n            }\r\n        }\r\n\r\n        _formattedSide.about = {\r\n            appVersion: navigator.appVersion,\r\n            userAgent: navigator.userAgent,\r\n            language: navigator.language,\r\n            languages: navigator.languages,\r\n        };\r\n        DrawTool._embroideryPaths.splice(4);\r\n        let designSide = DrawTool._designBorders.find(b => b.sideId === this.id);\r\n        let designSideEmbroider = DrawTool._embroideryPaths.find((b: any) => b.sideId === this.id);\r\n        if (typeof designSide !== 'undefined') {\r\n            let paths = DrawTool.recs2paths(designSide.border);\r\n            const pathOset = 1.1;\r\n            var ptS = '';\r\n            designSideEmbroider.border.forEach((el: any) => {\r\n                if (el.paths && el.cm) {\r\n                    ptS += el.paths + ' ';\r\n                }\r\n            });\r\n            if ((DrawTool.modeToolDraw == DrawTool.modeSetup.EMBROIDER)) {\r\n                var patN: any = {\r\n                    paths: [ptS],\r\n                    cm: designSideEmbroider.bd.cm,\r\n                    pixel: designSideEmbroider.bd.pixel\r\n                };\r\n                if (designSideEmbroider.sideId !== '1') {\r\n                    delete patN.paths;\r\n                }\r\n                _formattedSide.design_border = patN;\r\n            }\r\n\r\n        }\r\n        return JSON.stringify(_formattedSide);\r\n    }\r\n\r\n    /**\r\n   *\r\n   * @param {String} json\r\n   */\r\n    fromJSONLayer(json: any, callback?: any, firstOfHistory = false, sizeOldWorkArea: any = false) {\r\n        let data = JSON.parse(escapeJSON(json));\r\n        let filters = {};\r\n        let proportionsOnOld = 1;\r\n        Array.prototype.forEach.call(data.canvas.objects, function (item, i) {\r\n            if (typeof item.filters != 'undefined' && item.filters.length > 0) {\r\n                // Object.defineProperty(filters, 'item.uuid', { value: item.filters })\r\n                (filters as any)[item.uuid] = item.filters;\r\n                item.filters = [];\r\n            }\r\n        });\r\n\r\n        this._removeEvents();\r\n\r\n        this.items._collection = [];\r\n\r\n        if (sizeOldWorkArea) {\r\n            if (this.FabricBorder.width < this.FabricBorder.height) {\r\n                proportionsOnOld = this.FabricBorder.width / sizeOldWorkArea.width;\r\n            } else {\r\n                proportionsOnOld = this.FabricBorder.height / sizeOldWorkArea.height;\r\n            }\r\n        }\r\n        let canvasData = JSON.stringify({ objects: data.canvas.objects });\r\n\r\n\r\n        this.FabricCanvas.loadFromJSON(canvasData, () => {\r\n            if (this.backdrop) {\r\n                this.FabricCanvas.backgroundImage = this.backdrop;\r\n            }\r\n            //this.setBorder(this.border);\r\n            this.FabricBorder.sendToBack();\r\n            this.FabricCanvas.renderAll.bind(this.FabricCanvas);\r\n            this._initEvents();\r\n            this.layers.update();\r\n\r\n            if (firstOfHistory) {\r\n                DrawTool.history.history[DrawTool.sides.selected.id].collection = [JSON.stringify(this.FabricCanvas)];\r\n                DrawTool.history.history[DrawTool.sides.selected.id].currentIndex = 0;\r\n            }\r\n        }, (o: any, item: any) => {\r\n\r\n            let scaleX = (this.getBorder().pixel.width / data.border.pixel.width);\r\n            let scaleY = (this.getBorder().pixel.height / data.border.pixel.height);\r\n            var valueScaleAction = scaleX;\r\n            if (scaleX > scaleY) valueScaleAction = scaleY;\r\n            scaleX = valueScaleAction * item.scaleX;\r\n            scaleY = valueScaleAction * item.scaleY;\r\n            if (valueScaleAction != 0) {\r\n                item.set({\r\n                    left: (this.center.x + item.left * valueScaleAction),\r\n                    top: (this.center.y + item.top * valueScaleAction),\r\n                    scaleX: scaleX,\r\n                    scaleY: scaleY,\r\n                    'sizeImage': 0,\r\n                    \"useItemData\": true,\r\n                    clipTo: this.overlay ? \"\" : clip(this.FabricBorder),\r\n                });\r\n            }\r\n            else {\r\n                item.set({\r\n                    left: this.center.x + ((item.left / data.factor.x) * ((this.getBorder().pixel.left || 1) / (this.defaultWorkspaceSize.left || 1))),\r\n                    top: this.center.y + ((item.top / data.factor.y) * ((this.getBorder().pixel.top || 1) / (this.defaultWorkspaceSize.top || 1))),\r\n                    scaleX: scaleX,\r\n                    scaleY: scaleY,\r\n                    'sizeImage': 0,\r\n                    \"useItemData\": true,\r\n                    clipTo: this.overlay ? \"\" : clip(this.FabricBorder),\r\n                });\r\n            }\r\n\r\n            if (item.uuid in filters) {\r\n                Array.prototype.forEach.call((filters as any)[item.uuid], (filter) => {\r\n                    if (filter.type === \"RemoveColor\") {\r\n                        let filterRemoveColor = new (fabric.fabric.Image.filters as any).RemoveColor({\r\n                            color: filter.color,\r\n                            distance: filter.distance\r\n                        });\r\n                        item.filters.push(filterRemoveColor);\r\n                        item.applyFilters(this.FabricCanvas.renderAll.bind(this.FabricCanvas));\r\n                    }\r\n                    else if (filter.type === \"ImageProcessingColor\") {\r\n                        let imageProcessingColor = new (fabric.fabric.Image.filters as any).ImageProcessingColor({\r\n                            color: filter.color,\r\n                            distance: filter.distance\r\n                        });\r\n                        item.filters.push(imageProcessingColor);\r\n                        item.applyFilters(this.FabricCanvas.renderAll.bind(this.FabricCanvas));\r\n                    }\r\n                    else if (filter.type === \"ChangeToCropPathProcessing\") {\r\n                        let filterChangeToCrop = new (fabric.fabric.Image.filters as any).ChangeToCropPathProcessing({\r\n                            color: filter.color,\r\n                            distance: filter.distance\r\n                        });\r\n                        item.filters.push(filterChangeToCrop);\r\n                        item.applyFilters(this.FabricCanvas.renderAll.bind(this.FabricCanvas));\r\n                    }\r\n                });\r\n            }\r\n\r\n            this.items._collection.push(item);\r\n            this.FabricCanvas.add(item)\r\n            if (data.is_empty) {\r\n                this.checkEmpty();\r\n            } else {\r\n                this.is_empty = data.is_empty;\r\n                this.number_embroider = data.number_embroider;\r\n                this.number_special_draw = data.number_special_draw;\r\n                this.number_draw = data.number_draw;\r\n                this.number_embroider_sp = data.number_embroider_sp;\r\n                this.number_print_draw = data.number_print_draw;\r\n            }\r\n\r\n            // this.items.triggerCreated();\r\n            this.FabricCanvas.renderAll()\r\n            if (typeof callback == 'function')\r\n                callback();\r\n        });\r\n        this.checkEmpty()\r\n    }\r\n\r\n    addItemLayer(json: any, old_work_area: any) {\r\n        if (this.getBorder().pixel.width === old_work_area.factor.x && this.getBorder().pixel.height === old_work_area.factor.y) {\r\n            this.fromJSONLayer(json);\r\n        } else {\r\n            this.fromJSONLayer(json, function () { }, false, old_work_area.size);\r\n        }\r\n    }\r\n\r\n    /**\r\n *\r\n * @private\r\n */\r\n    initGrid() {\r\n\r\n        if (!this.cmSize) {\r\n            throw (new Error(JSON.stringify({ error: errors.sideNoSize })));\r\n            return false;\r\n        }\r\n\r\n        var state;\r\n\r\n        if (this.grid) {\r\n            state = this.grid.visible;\r\n            this.grid.destroy();\r\n            this.FabricCanvas.remove(this.grid);\r\n        } else {\r\n            state = false;\r\n        }\r\n\r\n        let cm = this.cmSize;\r\n\r\n        let stepX = cm.width;\r\n        let stepY = cm.height;\r\n\r\n        this.grid = new fabric.fabric.Group(undefined, {\r\n            // excludeFromExport: true,\r\n            hasControls: false,\r\n            hoverCursor: 'default',\r\n            selectable: false\r\n        });\r\n\r\n        this.FabricCanvas.add(this.grid);\r\n\r\n        this.grid.sendToBack();\r\n\r\n        this.grid.enable = function (val = true) {\r\n            this.setVisible(val);\r\n            this.canvas.renderAll();\r\n        };\r\n\r\n        this.grid.setVisible(state);\r\n        this.FabricCanvas.renderAll();\r\n\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @private\r\n     */\r\n    initRuler() {\r\n\r\n        if (!this.cmSize) {\r\n            throw (new Error(JSON.stringify({ error: errors.sideNoSize })));\r\n            return false;\r\n        }\r\n\r\n        var state;\r\n\r\n        if (this.ruler) {\r\n            state = this.ruler.visible;\r\n            this.ruler.destroy();\r\n            this.FabricCanvas.remove(this.ruler);\r\n        } else {\r\n            state = false;\r\n        }\r\n\r\n        let cm = this.cmSize;\r\n\r\n        let stepX = cm.width;\r\n        let stepY = cm.height;\r\n\r\n        this.ruler = new fabric.fabric.Group(undefined, {\r\n            // excludeFromExport: true,\r\n            hasControls: false,\r\n            hoverCursor: 'default',\r\n            selectable: false\r\n        });\r\n\r\n        for (var x = stepX * 2; x <= this.FabricCanvas.width; x += stepX) {\r\n            this.ruler.add(new fabric.fabric.Line([x, 0, x, stepY * 2], { stroke: 'rgba(0, 0, 0, 0.2)', selectable: false, hoverCursor: 'default' }));\r\n        }\r\n\r\n        for (var y = stepY * 2; y <= this.FabricCanvas.height; y += stepY) {\r\n            this.ruler.add(new fabric.fabric.Line([0, y, stepX * 2, y], { stroke: 'rgba(0, 0, 0, 0.2)', selectable: false, hoverCursor: 'default' }));\r\n        }\r\n\r\n        this.FabricCanvas.add(this.ruler);\r\n\r\n        this.ruler.enable = function (val = true) {\r\n            this.setVisible(val);\r\n            this.canvas.renderAll();\r\n        };\r\n\r\n        this.ruler.setVisible(state);\r\n        this.FabricCanvas.renderAll();\r\n    }\r\n\r\n\r\n    // * Set side image\r\n    // * @param {String} url\r\n    // * @param size {Object} size\r\n    // * @param size.width {Number} Width of image in centimeters\r\n    // * @param size.height {Number} Height of image in centimeters\r\n    // * @param proportions {Number}\r\n    // * @param borderSize {Object}\r\n    // * @return {Promise}\r\n    setImage(url: string, size?: any, proportions: any = 1, borderSize?: any) {\r\n        this.size = size;\r\n\r\n        this.imageUrl = url;\r\n\r\n        let center = this.FabricCanvas.getCenter();\r\n\r\n        return new Promise((resolve, reject) => {\r\n\r\n            this.FabricCanvas.setBackgroundColor('#ffffff');\r\n\r\n            fabric.fabric.Image.fromURL(url, imgObj => {\r\n\r\n\r\n                this.FabricCanvas.setBackgroundImage(imgObj, (img: any) => {\r\n                    this.backdrop = this.FabricCanvas.backgroundImage;\r\n\r\n                    this.backdrop.excludeFromExport = true;\r\n\r\n                    let canvasAspectRatio = this.canvas.width / this.canvas.height;\r\n                    let borderAspectRatio = borderSize.width / borderSize.height;\r\n\r\n                    if (canvasAspectRatio < borderAspectRatio) {\r\n                        let canvasProportions = this.FabricCanvas.width / this.size.width;\r\n                        this.bgProportions = (this.FabricCanvas.width * proportions) / (borderSize.width * canvasProportions);\r\n\r\n                        // this.backdrop.scaleToWidth(this.size.width * canvasProportions * this.bgProportions);\r\n                        this.backdrop.scaleToWidth(this.FabricCanvas.width)\r\n                    } else {\r\n                        let canvasProportions = this.FabricCanvas.height / this.size.height;\r\n                        this.bgProportions = (this.FabricCanvas.height * proportions) / (borderSize.height * canvasProportions);\r\n\r\n                        // this.backdrop.scaleToHeight(this.size.height * canvasProportions * this.bgProportions);\r\n                        this.backdrop.scaleToHeight(this.FabricCanvas.height)\r\n                    }\r\n\r\n                    this._setOffset(borderSize);\r\n\r\n                    this.FabricCanvas.backgroundImage.top -= this.bgOffset.top;\r\n                    this.FabricCanvas.backgroundImage.left -= this.bgOffset.left;\r\n\r\n                    this.cmSize = this._calculateSize();\r\n\r\n                    this.FabricCanvas.renderAll();\r\n\r\n                    DrawTool.trigger('backdrop:loaded', { side: { id: this.id } });\r\n\r\n                    DrawTool.history.pushState(this.id);\r\n                    resolve({ side: { id: this.id } });\r\n                }, {\r\n                    top: center.top,\r\n                    left: center.left,\r\n                    originX: 'center',\r\n                    originY: 'center',\r\n                    opacity: 1,\r\n                    crossOrigin: 'anonymous'\r\n\r\n                });\r\n\r\n                // imgObj.scaleToWidth(this.size.width* (this.FabricCanvas.height / this.size.height)* this.bgProportions);\r\n                // imgObj.scaleToHeight(this.size.height* (this.FabricCanvas.height / this.size.height)* this.bgProportions);\r\n                imgObj.scaleToWidth(this.FabricCanvas.width);\r\n                imgObj.scaleToHeight(this.FabricCanvas.height);\r\n                this.FabricCanvas.renderAll();\r\n            })\r\n\r\n        });\r\n    }\r\n\r\n    _setOffset(borderSize: any) {\r\n        this.bgOffset = {\r\n            left: 0,\r\n            top: 0\r\n        };\r\n\r\n        this.bgOffset.left = (borderSize.left - ((this.size.width - borderSize.width) / 2)) * this.backdrop.scaleX;\r\n        this.bgOffset.top = (borderSize.top - ((this.size.height - borderSize.height) / 2)) * this.backdrop.scaleY;\r\n\r\n        return true;\r\n    }\r\n\r\n    _calculateSize() {\r\n        this.cmSize = {\r\n            width: ((this.backdrop.width * this.backdrop.scaleX) / this.size.width),\r\n            height: ((this.backdrop.height * this.backdrop.scaleY) / this.size.height)\r\n        };\r\n        return this.cmSize;\r\n    }\r\n\r\n    zoomToVal(val: Number) {\r\n        let center = this.FabricBorder.getCenterPoint();\r\n        this.FabricCanvas.zoomToPoint(center, val);\r\n        return this;\r\n    }\r\n\r\n\r\n\r\n    _initFabric() {\r\n\r\n        this.FabricCanvas = new fabric.fabric.Canvas(this.canvas, {\r\n            selection: false,\r\n            enableRetinaScaling: true,\r\n            preserveObjectStacking: true\r\n        });\r\n\r\n        // this.FabricCanvas.toJSON('objects.brush');\r\n\r\n        this.FabricCanvas.wrapperEl.style.display = 'none';\r\n        this.FabricCanvas.upperCanvasEl.style['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\r\n        this.FabricCanvas.lowerCanvasEl.style['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\r\n    }\r\n\r\n\r\n    _initEvents() {\r\n        this.FabricCanvas.on({\r\n            'after:render': (e: any) => {\r\n                DrawTool.trigger('after:render', {});\r\n            },\r\n            'object:added': (e: any) => {\r\n                if (e.target.id !== \"FabricBorder\") {\r\n                    this.is_empty = false;\r\n                }\r\n                if (!e.target.excludeFromExport) {\r\n                    DrawTool.trigger('object:added', { side: { id: this.id }, item: e.target.toObject(['brush', 'editable', 'vertical', 'uuid']).uuid });\r\n                }\r\n            },\r\n            'selection:cleared': (e: any) => {\r\n                if (this.items.selected.item) {\r\n                    this.items.selected.item.selected = false;\r\n                }\r\n                this.items.selected.item = null;\r\n                DrawTool.trigger('selection:cleared', e);\r\n            },\r\n            'selection:created': (e: any) => {\r\n                DrawTool.trigger('selection:created', e);\r\n            },\r\n            'object:selected': (e: any) => {\r\n                if (e.target.id === 'FabricBorder') {\r\n                    e.target.setCoords();\r\n                    this.center = this.FabricBorder.getCenterPoint();\r\n                }\r\n                this.items.selected.item = e.target;\r\n                this.items.selected.item.selected = true;\r\n                DrawTool.trigger('object:selected', { side: { id: this.id }, isWorkSpaceBorder: e.target.id === 'FabricBorder' });\r\n            },\r\n            'object:modified': (e: any) => {\r\n                this.checkEmpty()\r\n                if (e.target.id === 'FabricBorder') {\r\n                    e.target.setCoords();\r\n                    this.center = this.FabricBorder.getCenterPoint();\r\n                    this.initWorkspaceGrid();\r\n                    this.initWorkspaceRuler();\r\n                }\r\n                DrawTool.trigger('object:modified', { side: { id: this.id }, isWorkSpaceBorder: e.target.id === 'FabricBorder', item: e.target.toObject(['brush', 'editable', 'vertical', 'uuid']).uuid });\r\n                if (!e.target.excludeFromExport) {\r\n                    DrawTool.trigger('history:update', { side: { id: this.id }, isWorkSpaceBorder: false });\r\n                }\r\n\r\n            },\r\n            'object:removed': (e: any) => {\r\n                this.checkEmpty()\r\n                if (e.target && !e.target.excludeFromExport) {\r\n                    DrawTool.trigger('object:removed', { side: { id: this.id }, item: e.target.toObject(['brush', 'editable', 'vertical', 'uuid']).uuid });\r\n                    DrawTool.trigger('history:update', { side: { id: this.id } });\r\n                }\r\n            },\r\n            'editing:exited': () => {\r\n                DrawTool.trigger('editing:exited', { side: { id: this.id } });\r\n            },\r\n            'editing:entered': () => {\r\n                DrawTool.trigger('editing:entered', { side: { id: this.id } });\r\n            },\r\n            'mouse:up': (e: any) => {\r\n                this._panningDown = false;\r\n\r\n                if (DrawTool.is_nail && this._zoom_zone) {\r\n                    var touches = e.e.touches && e.e.touches.length ? e.e.touches : [e.e];\r\n                    var evt = (e.e.changedTouches && e.e.changedTouches[0]) || touches[0];\r\n\r\n                    let x = evt.layerX || evt.pageX || 0;\r\n                    let y = evt.layerY || evt.pageY || 0;\r\n\r\n                    if (DrawTool.is_mobile) {\r\n                        y -= 65;\r\n                        this._pan_y0 -= 65;\r\n                    }\r\n\r\n                    let centerX = (x + this._pan_x0) / 2;\r\n                    let centerY = (y + this._pan_y0) / 2;\r\n\r\n                    let min: any = {};\r\n                    let minPathIndex = 0;\r\n                    let minDistance = 1000000;\r\n                    let zoom = this.FabricCanvas.getZoom();\r\n\r\n                    this.FabricBorder._objects.map((o: any, index: number) => {\r\n                        if (index !== 0) {\r\n                            let aX = this.FabricBorder.oCoords.tl.x + (o.aCoords.tl.x + o.aCoords.tr.x) * zoom / 2;\r\n                            let aY = this.FabricBorder.oCoords.tl.y + (o.aCoords.tl.y + o.aCoords.bl.y) * zoom / 2;\r\n                            let currentDistance = Math.sqrt(Math.pow(aX - centerX, 2) + Math.pow(aY - centerY, 2));\r\n                            if (currentDistance < minDistance) {\r\n                                minDistance = currentDistance;\r\n                                minPathIndex = index;\r\n                                min = { x: aX, y: aY };\r\n                            }\r\n                        }\r\n                    });\r\n\r\n                    let pointMinX = Math.min(x, this._pan_x0);\r\n                    let pointMinY = Math.min(y, this._pan_y0);\r\n                    let pointMaxX = Math.max(x, this._pan_x0);\r\n                    let pointMaxY = Math.max(y, this._pan_y0);\r\n\r\n                    let minPath = this.FabricBorder._objects[minPathIndex];\r\n                    let pathMinX = this.FabricBorder.oCoords.tl.x + minPath.aCoords.tl.x * zoom;\r\n                    let pathMinY = this.FabricBorder.oCoords.tl.y + minPath.aCoords.tl.y * zoom;\r\n                    let pathMaxX = this.FabricBorder.oCoords.tl.x + minPath.aCoords.tr.x * zoom;\r\n                    let pathMaxY = this.FabricBorder.oCoords.tl.y + minPath.aCoords.bl.y * zoom;\r\n\r\n                    if (pointMinX <= pathMinX &&\r\n                        pointMinY <= pathMinY &&\r\n                        pointMaxX >= pathMaxX &&\r\n                        pointMaxY >= pathMaxY) {\r\n                        this._selected_path_index = minPathIndex;\r\n                        this.FabricCanvas.relativePan({ x: this.center.x - min.x, y: this.center.y - min.y });\r\n                        this.FabricCanvas.renderAll();\r\n\r\n                        let center = new fabric.fabric.Point(this.FabricCanvas.getWidth() / 2, this.FabricCanvas.getHeight() / 2);\r\n                        this.FabricCanvas.zoomToPoint(center, 3);\r\n                        this.FabricCanvas.renderAll();\r\n                    }\r\n                }\r\n            },\r\n            'mouse:down': (e: any) => {\r\n                this._panningDown = true;\r\n\r\n                var touches = e.e.touches && e.e.touches.length ? e.e.touches : [e.e];\r\n                var evt = (e.e.changedTouches && e.e.changedTouches[0]) || touches[0];\r\n\r\n                this._pan_x0 = evt.layerX || evt.pageX || 0;\r\n                this._pan_y0 = evt.layerY || evt.pageY || 0;\r\n\r\n                if (this.colorPicker.active) {\r\n                    this.colorPicker.move(e);\r\n                    DrawTool.trigger('colorpicker:update', this.colorPicker.color);\r\n                }\r\n\r\n            },\r\n            'mouse:move': (e: any) => {\r\n\r\n                //  DrawTool.trigger('mouse:move');\r\n\r\n                if (!!(this._panning && this._panningDown && e && e.e)) {\r\n\r\n                    var touches = e.e.touches && e.e.touches.length ? e.e.touches : [e.e];\r\n                    var evt = (e.e.changedTouches && e.e.changedTouches[0]) || touches[0];\r\n\r\n                    let x = evt.layerX || evt.pageX || 0;\r\n                    let y = evt.layerY || evt.pageY || 0;\r\n\r\n                    this.FabricCanvas.relativePan({ x: x - this._pan_x0, y: y - this._pan_y0 });\r\n                    this._pan_x0 = x;\r\n                    this._pan_y0 = y;\r\n                }\r\n                if (this.colorPicker.active) {\r\n                    this.colorPicker.move(e);\r\n                }\r\n            },\r\n            'object:moving': (e: any) => {\r\n                if (DrawTool.is_embroidery) {\r\n                    if (!!(e && e.e && e.target)) {\r\n                        var angle = 0;\r\n                        if (e.target.angle) angle = e.target.angle;\r\n                        var left1 = this.FabricBorder._originalLeft;\r\n                        var left2 = left1 + this.FabricBorder.width;\r\n                        var widthDiv2 = e.target.width / 2 * e.target.scaleX * Math.abs(Math.cos(angle * Math.PI / 180)) +\r\n                            e.target.height / 2 * e.target.scaleY * Math.abs(Math.sin(angle * Math.PI / 180));\r\n                        if ((e.target.left + widthDiv2) > left2) {\r\n                            e.target.left = left2 - widthDiv2;\r\n                        }\r\n                        else\r\n                            if ((e.target.left - widthDiv2) < left1) {\r\n                                e.target.left = left1 + widthDiv2;\r\n                            }\r\n                    }\r\n                } else {\r\n                    if (!!(e && e.e && e.target)) {\r\n                        if (Math.abs(e.target.left - this.center.x) < 5) {\r\n                            e.target.left = this.center.x;\r\n                            e.target.actionMoveX = true;\r\n                        }\r\n                        else {\r\n                            e.target.actionMoveX = false;\r\n                        }\r\n\r\n                        if (Math.abs(e.target.top - this.center.y) < 5) {\r\n                            e.target.top = this.center.y;\r\n                            e.target.actionMoveY = true;\r\n                        }\r\n                        else {\r\n                            e.target.actionMoveY = false;\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            'object:scaling': (e: any) => {\r\n                if (!!e.e.touches && e.e.touches.length > 1) {\r\n                    return false\r\n                } else {\r\n                    let obj = e.target;\r\n                    if (DrawTool.is_embroidery) {\r\n                        var angle = 0;\r\n                        if (e.target.angle) angle = e.target.angle;\r\n                        var left1 = this.FabricBorder._originalLeft;\r\n                        var left2 = left1 + this.FabricBorder.width;\r\n                        var widthDiv2 = e.target.width * e.target.scaleX * Math.abs(Math.cos(angle * Math.PI / 180)) + e.target.height / 2 * e.target.scaleY * Math.abs(Math.sin(angle * Math.PI / 180));\r\n                        if (widthDiv2 > this.FabricBorder.width) {\r\n                            widthDiv2 = this.FabricBorder.width / 2;\r\n                            e.target.left = left2 - widthDiv2;\r\n                            e.target.scaleToWidth(this.FabricBorder.width);\r\n                        }\r\n                        else {\r\n                            widthDiv2 = widthDiv2 / 2;\r\n                            if (e.target.left + widthDiv2 > left2) {\r\n                                e.target.left = left2 - widthDiv2;\r\n                            } else if (e.target.left - widthDiv2 < left1) {\r\n                                e.target.left = left1 + widthDiv2;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (obj.type.includes('path') || obj.type.includes('i-text') || obj.type.includes('curvedText')) {\r\n                        return false;\r\n                    }\r\n\r\n                    let w = obj.width * obj.scaleX;\r\n                    let h = obj.height * obj.scaleY;\r\n                    let s = obj.strokeWidth;\r\n\r\n                    obj.set({\r\n                        'height': h,\r\n                        'width': w,\r\n                        'scaleX': 1,\r\n                        'scaleY': 1\r\n                    });\r\n                }\r\n            },\r\n            'object:rotating': function objectRotate(e: any) {\r\n                DrawTool.trigger('object:rotating');\r\n            },\r\n        });\r\n    }\r\n\r\n    saveBoder(start: any, special = null) {\r\n        this.border_special = special;\r\n        this.start_boder = start;\r\n    }\r\n\r\n    async setOverlayBorder(overlayImage: any, reset = false) {\r\n        if (reset) {\r\n            if (this.overlayImage !== null) {\r\n                overlayImage = this.overlayImage;\r\n            }\r\n            else {\r\n                return;\r\n            }\r\n        }\r\n        else {\r\n            this.overlayImage = overlayImage;\r\n        }\r\n        setTimeout(() => {\r\n            let center = this.FabricCanvas.getCenter();\r\n            this.FabricCanvas.setOverlayImage(overlayImage, () => {\r\n                this.FabricCanvas.overlayImage.scaleX = this.backdrop.scaleX;\r\n                this.FabricCanvas.overlayImage.scaleY = this.backdrop.scaleY;\r\n                this.FabricCanvas.overlayImage.originX = 'center';\r\n                this.FabricCanvas.overlayImage.originY = 'center';\r\n                this.FabricCanvas.overlayImage.top = center.top - this.bgOffset.top;\r\n                this.FabricCanvas.overlayImage.left = center.left - this.bgOffset.left;\r\n                this.FabricCanvas.renderAll();\r\n            });\r\n            this.FabricCanvas.forEachObject((item: any) => {\r\n                item.setClipTo(null);\r\n            })\r\n            this.FabricCanvas.renderAll();\r\n        }, 500);\r\n    }\r\n\r\n    /**\r\n  *\r\n  * @private\r\n  */\r\n    initWorkspaceGrid() {\r\n\r\n        if (!this.cmSize) {\r\n            throw (new Error(JSON.stringify({ error: errors.sideNoSize })));\r\n            return false;\r\n        }\r\n\r\n        var state;\r\n\r\n        if (this.workspaceGrid) {\r\n            state = this.workspaceGrid.visible;\r\n            this.workspaceGrid.destroy();\r\n            this.FabricCanvas.remove(this.workspaceGrid);\r\n        } else {\r\n            state = false;\r\n        }\r\n\r\n        let cm = this.cmSize;\r\n\r\n        this.workspaceGrid = new fabric.fabric.Group(undefined, {\r\n            // excludeFromExport: true,\r\n            hasControls: false,\r\n            hoverCursor: 'default',\r\n            selectable: false\r\n        });\r\n\r\n        for (var x = this.FabricBorder.left; x <= this.FabricBorder.left + this.FabricBorder.width; x += cm.width) {\r\n            this.workspaceGrid.add(new fabric.fabric.Line([x, this.FabricBorder.top, x, this.FabricBorder.top + this.FabricBorder.height], { stroke: DrawTool.grid.color, strokeWidth: DrawTool.grid.strokeWidth, selectable: false, hoverCursor: 'default' }));\r\n        }\r\n\r\n        for (var y = this.FabricBorder.top; y <= this.FabricBorder.top + this.FabricBorder.height; y += cm.height) {\r\n            this.workspaceGrid.add(new fabric.fabric.Line([this.FabricBorder.left, y, this.FabricBorder.left + this.FabricBorder.width, y], { stroke: DrawTool.grid.color, strokeWidth: DrawTool.grid.strokeWidth, selectable: false, hoverCursor: 'default' }));\r\n        }\r\n\r\n        this.FabricCanvas.add(this.workspaceGrid);\r\n\r\n        this.grid.sendToBack();\r\n\r\n        this.workspaceGrid.enable = function (val = true) {\r\n            this.setVisible(val);\r\n            this.canvas.renderAll();\r\n        };\r\n\r\n        this.workspaceGrid.setVisible(state);\r\n        this.FabricCanvas.renderAll();\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     *\r\n     * @private\r\n     */\r\n    initWorkspaceRuler() {\r\n        if (!this.cmSize) {\r\n            throw (new Error(JSON.stringify({ error: errors.sideNoSize })));\r\n            return false;\r\n        }\r\n\r\n        var state;\r\n\r\n        if (this.workspaceRuler) {\r\n            state = this.workspaceRuler.visible;\r\n            this.workspaceRuler.destroy();\r\n            this.FabricCanvas.remove(this.workspaceRuler);\r\n        } else {\r\n            state = false;\r\n        }\r\n\r\n        let cm = this.cmSize;\r\n\r\n        this.workspaceRuler = new fabric.fabric.Group(undefined, {\r\n            // excludeFromExport: true,\r\n            hasControls: false,\r\n            hoverCursor: 'default',\r\n            selectable: false\r\n        });\r\n\r\n        for (var x = this.FabricBorder.left; x <= this.FabricBorder.left + this.FabricBorder.width; x += cm.width) {\r\n            this.workspaceRuler.add(new fabric.fabric.Line([x, cm.height, x, cm.height * 2], { stroke: 'rgba(0, 0, 0, 0.2)', selectable: false, hoverCursor: 'default' }));\r\n        }\r\n\r\n        for (var y = this.FabricBorder.top; y <= this.FabricBorder.top + this.FabricBorder.height; y += cm.height) {\r\n            this.workspaceRuler.add(new fabric.fabric.Line([cm.width, y, cm.width * 2, y], { stroke: 'rgba(0, 0, 0, 0.2)', selectable: false, hoverCursor: 'default' }));\r\n        }\r\n\r\n        this.workspaceRuler.add(new fabric.fabric.Line([this.FabricBorder.left, cm.height * 1.5, this.FabricBorder.left + this.FabricBorder.width, cm.height * 1.5], { stroke: 'rgba(0, 0, 0, 0.2)', selectable: false, hoverCursor: 'default' }));\r\n        this.workspaceRuler.add(new fabric.fabric.Line([cm.width * 1.5, this.FabricBorder.top, cm.width * 1.5, this.FabricBorder.top + this.FabricBorder.height], { stroke: 'rgba(0, 0, 0, 0.2)', selectable: false, hoverCursor: 'default' }));\r\n\r\n\r\n        this.FabricCanvas.add(this.workspaceRuler);\r\n\r\n        this.workspaceRuler.enable = function (val = true) {\r\n            this.setVisible(val);\r\n            this.canvas.renderAll();\r\n        };\r\n\r\n        this.workspaceRuler.setVisible(state);\r\n        this.FabricCanvas.renderAll();\r\n    }\r\n\r\n\r\n\r\n    setSelectableForDesign() {\r\n        let that1 = this;\r\n        if (this._panning) {\r\n            this.items._collection.forEach((object: any) => object.selectable = false);\r\n        } else {\r\n            this.items._collection.forEach((object: any) => {\r\n                if (DrawTool.is_embroidery) {\r\n                    if (object.pathIndex) {\r\n                        //|| DrawTool.is_area_embroider !== object.areaEmbroider \r\n                        if (object.pathIndex === -1) {\r\n                            object.selectable = false;\r\n                            object.evented = false;\r\n                        }\r\n                        else {\r\n                            if (object.pathIndex === 1) {\r\n                                if (!!!object.areaEmbroider) {\r\n                                    let border = DrawTool.sides.selected.FabricBorder;\r\n                                    let border_coords = that1.getValuefromHash(border.aCoords);\r\n                                    if (that1.doPolygonsIntersect(border_coords, that1.getValuefromHash(object.aCoords)) && object.id !== \"FabricBorder\") {\r\n                                        object.selectable = true;\r\n                                        object.evented = true;\r\n                                    }\r\n                                    else {\r\n                                        object.selectable = false;\r\n                                        object.evented = false;\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    if (DrawTool.is_area_embroider !== object.areaEmbroider) {\r\n                                        object.selectable = false;\r\n                                        object.evented = false;\r\n                                    }\r\n                                    else {\r\n                                        object.selectable = true;\r\n                                        object.evented = true;\r\n                                    }\r\n                                }\r\n                            }\r\n                            else {\r\n                                object.selectable = false;\r\n                                object.evented = false;\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        object.selectable = false;\r\n                        object.evented = false;\r\n                    }\r\n                } else {\r\n                    if (DrawTool.modeSpecialDrawEnable > 1) {\r\n                        if (object.pathIndex === DrawTool.modeSpecialDrawEnable) {\r\n                            object.selectable = true;\r\n                            object.evented = true;\r\n                        }\r\n                        else {\r\n                            object.selectable = false;\r\n                            object.evented = false;\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (object.pathIndex > 0) {\r\n                            object.selectable = false;\r\n                            object.evented = false;\r\n                        }\r\n                        else {\r\n                            object.selectable = true;\r\n                            object.evented = true;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    _removeEvents() {\r\n        this.FabricCanvas.off();\r\n    }\r\n\r\n    /**\r\n *\r\n * @param {String} json\r\n */\r\n    fromJSON(json: String, callback?: any, firstOfHistory = false, sizeOldWorkArea: any = false) {\r\n        let data = JSON.parse(escapeJSON(json));\r\n        let filters = {} as any;\r\n        let proportionsOnOld = 1;\r\n        Array.prototype.forEach.call(data.canvas.objects, function (item) {\r\n            if (typeof item.filters != 'undefined' && item.filters.length > 0) {\r\n                filters[item.uuid] = item.filters;\r\n                item.filters = [];\r\n            }\r\n        });\r\n\r\n        this._removeEvents();\r\n\r\n        this.items._collection = [];\r\n\r\n        if (sizeOldWorkArea) {\r\n            if (this.FabricBorder.width < this.FabricBorder.height) {\r\n                proportionsOnOld = this.FabricBorder.width / sizeOldWorkArea.width;\r\n            } else {\r\n                proportionsOnOld = this.FabricBorder.height / sizeOldWorkArea.height;\r\n            }\r\n        }\r\n\r\n        // let canvasData = JSON.stringify({ objects: data.canvas.objects });\r\n        let canvasData = data.canvas.objects\r\n        console.log(canvasData);\r\n\r\n        DrawTool.modeToolDraw = DrawTool.modeSetup.TAP_RIBBON\r\n        this.FabricCanvas.loadFromJSON(canvasData, () => {\r\n            if (this.backdrop) {\r\n                this.FabricCanvas.backgroundImage = this.backdrop;\r\n            }\r\n            this.setBorder(this.border);\r\n            this.FabricBorder.sendToBack();\r\n            this.FabricCanvas.renderAll.bind(this.FabricCanvas);\r\n            this._initEvents();\r\n            this.layers.update();\r\n\r\n            if (firstOfHistory) {\r\n                DrawTool.history.history[DrawTool.sides.selected.id].collection = [JSON.stringify(this.FabricCanvas)];\r\n                DrawTool.history.history[DrawTool.sides.selected.id].currentIndex = 0;\r\n            }\r\n        }, (o: any, item: any) => {\r\n            let scaleX = (this.getBorder().pixel.width / data.border.pixel.width);\r\n            let scaleY = (this.getBorder().pixel.height / data.border.pixel.height);\r\n            var valueScaleAction = scaleX;\r\n            if (scaleX > scaleY) valueScaleAction = scaleY;\r\n            scaleX = valueScaleAction * item.scaleX;\r\n            scaleY = valueScaleAction * item.scaleY;\r\n            if (valueScaleAction !== 0) {\r\n                item.set({\r\n                    left: (this.center.x + item.left * valueScaleAction),\r\n                    top: (this.center.y + item.top * valueScaleAction),\r\n                    scaleX: scaleX,\r\n                    scaleY: scaleY,\r\n                    'sizeImage': 0,\r\n                    \"useItemData\": true,\r\n                    clipTo: this.overlay ? \"\" : clip(this.FabricBorder),\r\n                });\r\n            }\r\n            else {\r\n                item.set({\r\n                    left: this.center.x + ((item.left / data.factor.x) * ((this.getBorder().pixel.left || 1) / (this.defaultWorkspaceSize.left || 1))),\r\n                    top: this.center.y + ((item.top / data.factor.y) * ((this.getBorder().pixel.top || 1) / (this.defaultWorkspaceSize.top || 1))),\r\n                    scaleX: scaleX,\r\n                    scaleY: scaleY,\r\n                    'sizeImage': 0,\r\n                    \"useItemData\": true,\r\n                    clipTo: this.overlay ? \"\" : clip(this.FabricBorder),\r\n                });\r\n            }\r\n            if (!item.pathIndex || item.pathIndex !== DrawTool.modeSetup.EMBROIDER) {\r\n                this.items.setClipOtherBorder(item, this.FabricBorder, null);\r\n            }\r\n            if (item.lastBorder) {\r\n                if (DrawTool.modeToolDraw === DrawTool.modeSetup.EMBROIDER) {\r\n                    if (item.pathIndex === DrawTool.modeSetup.EMBROIDER) {\r\n                        var dataBoder = JSON.parse(item.lastBorder);\r\n                        dataBoder.isSetup = false;\r\n                        item.lastBorder = JSON.stringify(dataBoder);\r\n                    }\r\n                    else {\r\n                        this.items.setClipOtherBorder(item, this.FabricBorder);\r\n                    }\r\n                }\r\n                else {\r\n                    delete item.lastBorder;\r\n                }\r\n            }\r\n\r\n            var ImageProcessingColorCheck = false;\r\n            var checkChangeToCropPathProcessing = false;\r\n            var colorCheck = [\"rgba(0,0,0,1)\", \"rgba(255,0,0,1)\", \"rgba(0,0,255,1)\", \"rgba(255,255,255,1)\"];\r\n            if (DrawTool.modeToolDraw === DrawTool.modeSetup.TAP_RIBBON) {\r\n                colorCheck.push(\"rgba(255,255,255,1)\");\r\n            }\r\n            else if (DrawTool.modeToolDraw === DrawTool.modeSetup.TAP_RIBBON_2EDIT) {\r\n                colorCheck.push(\"rgba(193,171,5,1)\");\r\n                colorCheck.push(\"rgba(192,192,192,1)\");\r\n            }\r\n\r\n            if (item.uuid in filters) {\r\n                Array.prototype.forEach.call(filters[item.uuid], (filter) => {\r\n                    if (!colorCheck.includes(filter.color)) filter.color = \"rgba(0,0,0,1)\";\r\n                    if (filter.type === \"RemoveColor\") {\r\n                        let filterRemoveColor = new (fabric.fabric.Image.filters as any).RemoveColor({\r\n                            color: filter.color,\r\n                            distance: filter.distance\r\n                        });\r\n                        item.filters.push(filterRemoveColor);\r\n                        item.applyFilters(this.FabricCanvas.renderAll.bind(this.FabricCanvas));\r\n                    }\r\n                    else if (filter.type === \"ImageProcessingColor\") {\r\n                        ImageProcessingColorCheck = true;\r\n                        let imageProcessingColor = new (fabric.fabric.Image.filters as any).ImageProcessingColor({\r\n                            color: filter.color,\r\n                            distance: filter.distance\r\n                        });\r\n                        item.filters.push(imageProcessingColor);\r\n                        item.applyFilters(this.FabricCanvas.renderAll.bind(this.FabricCanvas));\r\n                    }\r\n                    else if (filter.type === \"ImageChangeColorAll\") {\r\n                        ImageProcessingColorCheck = true;\r\n                        let imageChangeColorAll = new (fabric.fabric.Image.filters as any).ImageChangeColorAll({\r\n                            color: filter.color,\r\n                            distance: filter.distance\r\n                        });\r\n                        item.filters.push(imageChangeColorAll);\r\n                        item.applyFilters(this.FabricCanvas.renderAll.bind(this.FabricCanvas));\r\n                    }\r\n                    else if (filter.type === \"ChangeToCropPathProcessing\") {\r\n                        checkChangeToCropPathProcessing = true;\r\n                        let changeToCropPathProcessing = new (fabric.fabric.Image.filters as any).ChangeToCropPathProcessing({\r\n                            color: filter.color,\r\n                            distance: filter.distance\r\n                        });\r\n                        item.filters.push(changeToCropPathProcessing);\r\n                        item.applyFilters(this.FabricCanvas.renderAll.bind(this.FabricCanvas));\r\n                    }\r\n                });\r\n            }\r\n            if ((DrawTool.modeToolDraw == DrawTool.modeSetup.TAP_RIBBON) || (DrawTool.modeToolDraw == DrawTool.modeSetup.TAP_RIBBON_2EDIT)) {\r\n                if (!!item.type) {\r\n                    if ((item.type === \"image\") && (!ImageProcessingColorCheck)) {\r\n                        if (!!!item.filters) item.filters = [];\r\n                        if (item.brush) {\r\n                            item.filters = [];\r\n                            var setColor = \"rgba(0,0,0,1)\";\r\n                            if (item.color) {\r\n                                if (colorCheck.includes(item.color)) setColor = item.color;\r\n                            }\r\n                            let imageChangeColorAll = new (fabric.fabric.Image.filters as any).ImageChangeColorAll({\r\n                                color: setColor,\r\n                                distance: 10\r\n                            });\r\n                            item.filters.push(imageChangeColorAll);\r\n                            item.applyFilters(this.FabricCanvas.renderAll.bind(this.FabricCanvas));\r\n                        }\r\n                        else {\r\n                            if ((item.filters.length == 0) || checkChangeToCropPathProcessing) {\r\n                                let imageProcessingColor = new (fabric.fabric.Image.filters as any).ImageProcessingColor({\r\n                                    color: \"rgba(0,0,0,1)\",\r\n                                    distance: 10\r\n                                });\r\n                                item.filters.push(imageProcessingColor);\r\n                                item.applyFilters(this.FabricCanvas.renderAll.bind(this.FabricCanvas));\r\n                            }\r\n                        }\r\n                    }\r\n                    else if (item.type === \"path-group\") {\r\n                        var enableSelectPath = false;\r\n                        if (!!item.paths) {\r\n                            var countItemColor = 0;\r\n                            item.paths.forEach(function (path: any) {\r\n                                if (colorCheck.includes(path.fill)) {\r\n                                    path.set('fill', path.fill);\r\n                                    enableSelectPath = true;\r\n                                }\r\n                                else {\r\n                                    path.set('fill', \"rgba(0,0,0,1)\");\r\n                                }\r\n                            });\r\n\r\n                        }\r\n                    }\r\n                    else if (item.type === \"i-text\") {\r\n                        if (!!item.text) {\r\n                            if (!colorCheck.includes(item.fill)) item.set('fill', \"rgba(0,0,0,1)\");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.items._collection.push(item);\r\n            this.FabricCanvas.add(item)\r\n            if (data.is_empty) {\r\n                this.checkEmpty();\r\n            } else {\r\n\r\n                if ((!!this.border_special) && (this.border_special.length === 1)) {\r\n                    delete data.number_embroider_sp.left;\r\n                }\r\n                this.is_empty = data.is_empty;\r\n                this.number_embroider = data.number_embroider;\r\n                this.number_special_draw = data.number_special_draw;\r\n                this.number_draw = data.number_draw;\r\n                this.number_embroider_sp = data.number_embroider_sp;\r\n                this.number_print_draw = data.number_print_draw;\r\n            }\r\n\r\n            this.items.triggerCreated();\r\n            this.FabricCanvas.renderAll()\r\n            if (typeof callback === 'function')\r\n                callback();\r\n        });\r\n        this.checkEmpty()\r\n    }\r\n\r\n    checkEmpty() {\r\n        if (DrawTool.sides.selected) {\r\n            let border = DrawTool.sides.selected.FabricBorder\r\n            let count = 0\r\n            let countEmbroider = 0;\r\n            let countSpecialDraw = 0;\r\n            var countPrintDraw = 0;\r\n            var nameEmbroiderSide;\r\n            let side = DrawTool.sides.selected;\r\n            let border_coords = this.getValuefromHash(border.aCoords)\r\n            side.FabricCanvas._objects.map((item: any) => {\r\n                if (this.doPolygonsIntersect(border_coords, this.getValuefromHash(item.aCoords)) && item.id !== \"FabricBorder\") {\r\n                    if (item.pathIndex === 1) {\r\n                        countEmbroider++;\r\n                    }\r\n                    if (item.pathIndex === -1) {\r\n                        countPrintDraw++;\r\n                    }\r\n                    else if (item.pathIndex > 2) countSpecialDraw++;\r\n                    count++;\r\n                }\r\n                return item\r\n            });\r\n            if (count === 0) {\r\n                side.is_empty = true;\r\n            } else {\r\n                side.is_empty = false;\r\n            }\r\n\r\n            side.number_embroider = countEmbroider;\r\n            side.number_special_draw = countSpecialDraw;\r\n            side.number_draw = count;\r\n\r\n            if (!DrawTool.is_embroidery) {\r\n                side.number_print_draw = countPrintDraw;\r\n            }\r\n            if (!side.number_embroider_sp) {\r\n                side.number_embroider_sp = {};\r\n            }\r\n            if (side.border.name) {\r\n                side.number_embroider_sp[side.border.name] = countEmbroider;\r\n            }\r\n\r\n            if (side.id === '3') {\r\n                nameEmbroiderSide = 'handLeft';\r\n                side.nameSide = 'handLeft'\r\n            }\r\n            if (side.id === '4') {\r\n                nameEmbroiderSide = 'handRight';\r\n                side.nameSide = 'handRight'\r\n            }\r\n            if (nameEmbroiderSide) {\r\n                side.number_embroider_sp[nameEmbroiderSide] = countEmbroider;\r\n            }\r\n        }\r\n    }\r\n\r\n    getValuefromHash(hash: any) {\r\n        var array_values = [];\r\n        for (var key in hash) {\r\n            array_values.push(hash[key]);\r\n        }\r\n        return array_values;\r\n    }\r\n\r\n    doPolygonsIntersect(a: any, b: any) {\r\n        let polygons = [a, b];\r\n        let minA, maxA, projected, i, i1, j, minB, maxB;\r\n        for (i = 0; i < polygons.length; i++) {\r\n            // for each polygon, look at each edge of the polygon, and determine if it separates\r\n            // the two shapes\r\n            let polygon = polygons[i];\r\n            for (i1 = 0; i1 < polygon.length; i1++) {\r\n                // grab 2 vertices to create an edge\r\n                let i2 = (i1 + 1) % polygon.length;\r\n                let p1 = polygon[i1];\r\n                let p2 = polygon[i2];\r\n                // find the line perpendicular to this edge\r\n                let normal = { x: p2.y - p1.y, y: p1.x - p2.x };\r\n                minA = maxA = undefined;\r\n                // for each vertex in the first shape, project it onto the line perpendicular to the edge\r\n                // and keep track of the min and max of these values\r\n                for (j = 0; j < a.length; j++) {\r\n                    projected = normal.x * a[j].x + normal.y * a[j].y;\r\n                    if ((!minA) || projected < minA) {\r\n                        minA = projected;\r\n                    }\r\n                    if ((!maxA) || projected > maxA) {\r\n                        maxA = projected;\r\n                    }\r\n                }\r\n                // for each vertex in the second shape, project it onto the line perpendicular to the edge\r\n                // and keep track of the min and max of these values\r\n                minB = maxB = undefined;\r\n                for (j = 0; j < b.length; j++) {\r\n                    projected = normal.x * b[j].x + normal.y * b[j].y;\r\n                    if ((!minB) || projected < minB) {\r\n                        minB = projected;\r\n                    }\r\n                    if ((!maxB) || projected > maxB) {\r\n                        maxB = projected;\r\n                    }\r\n                }\r\n\r\n                // if there is no overlap between the projects, the edge we are looking at separates the two\r\n                // polygons, and we know there is no overlap\r\n                if (maxA! < minB! || maxB! < minA!) {\r\n                    console.log(\"polygons don't intersect!\");\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // toJSON() {\r\n    //     DrawTool.is_data.map((side: Side) => {\r\n    //         if (side.border_special) {\r\n    //             let borderEmbroider1: any = { sideId: side.id, border: side.border_special, bd: side.border }\r\n    //             DrawTool._embroideryPaths.push(borderEmbroider1);\r\n\r\n    //         } else {\r\n    //             var pathEmbroider = `M${side.border.cm.left} ${side.border.cm.top} h${side.border.cm.width} v${side.border.cm.height} h-${side.border.cm.width} Z`;\r\n    //             if (DrawTool.embroider_able) {\r\n    //                 side.border.paths = [pathEmbroider];\r\n    //             }\r\n    //             var borderEmbroider2 = { sideId: side.id, border: [{ cm: side.border.cm, paths: side.border.paths, pixel: side.border.pixel, name: \"\" }], bd: side.border };\r\n    //             DrawTool._embroideryPaths.push(borderEmbroider2);\r\n    //         }\r\n    //     });\r\n\r\n    //     let _formattedSide: any = {\r\n    //         id: this.id,\r\n    //         imageUrl: this.imageUrl,\r\n    //         size: this.size,\r\n    //         is_empty: this.is_empty,\r\n    //         number_embroider: this.number_embroider,\r\n    //         number_special_draw: this.number_special_draw,\r\n    //         number_draw: this.number_draw,\r\n    //         number_embroider_sp: this.number_embroider_sp,\r\n    //         number_print_draw: this.number_print_draw,\r\n    //         canvas: this.FabricCanvas.toObject(['brush', 'editable', 'vertical', 'color', 'typeSVG', 'pathIndex', 'fileContent', 'fileContentURL', 'typePaths', 'lastBorder', 'areaEmbroider', 'pathDLaser']),\r\n    //         fonts: DrawTool.fonts,\r\n    //         border_special: this.border_special,\r\n    //     };\r\n\r\n    //     var itemOrder = [];\r\n\r\n    //     for (var i = 0; i < _formattedSide.canvas.objects.length; i++) {\r\n    //         if (_formattedSide.canvas.objects[i].pathIndex) {\r\n    //             if (_formattedSide.canvas.objects[i].pathIndex < 1) {\r\n    //                 itemOrder.push(_formattedSide.canvas.objects[i]);\r\n    //             }\r\n    //         }\r\n    //         else {\r\n    //             itemOrder.push(_formattedSide.canvas.objects[i]);\r\n    //         }\r\n    //     }\r\n\r\n    //     for (var i = 0; i < _formattedSide.canvas.objects.length; i++) {\r\n    //         if ((_formattedSide.canvas.objects[i].pathIndex) && (_formattedSide.canvas.objects[i].pathIndex > 0)) {\r\n    //             itemOrder.push(_formattedSide.canvas.objects[i]);\r\n    //         }\r\n\r\n    //     }\r\n    //     _formattedSide.canvas.objects = itemOrder;\r\n\r\n    //     _formattedSide.canvas.objects.forEach((item: any, i: any) => {\r\n    //         item.left = item.left - this.center.x;\r\n    //         item.top = item.top - this.center.y;\r\n    //         item.clipTo = null;\r\n    //         if (!item.type.includes('text') && !!item.fill) {\r\n    //             item.fill = null\r\n    //         }\r\n\r\n    //         if (item.selected) {\r\n    //             item.selectable = false;\r\n    //         }\r\n\r\n    //         if (item.type.includes('text') && DrawTool.rasterizedText) {\r\n    //             if (DrawTool.rasterizedText![item.uuid]) {\r\n    //                 let textObject = fabric.fabric.util.object.clone(item);\r\n    //                 item.visible = false;\r\n\r\n    //                 textObject.type = 'image';\r\n    //                 textObject.fill = 'rgb(0,0,0)';\r\n    //                 textObject.strokeWidth = 0;\r\n    //                 textObject.crossOrigin = 'anonymous';\r\n    //                 textObject.src = DrawTool.rasterizedText![item.uuid];\r\n    //                 textObject.alignX = 'none';\r\n    //                 textObject.alignY = 'none';\r\n    //                 textObject.meetOrSlice = 'meet';\r\n    //                 textObject.filters = [];\r\n    //                 textObject.resizeFilters = [];\r\n    //                 textObject.width = textObject.width * textObject.scaleX + textObject.width * textObject.scaleX * 0.1;\r\n    //                 textObject.height = textObject.height * textObject.scaleY + textObject.height * textObject.scaleY * 0.1;\r\n    //                 textObject.scaleX = 1;\r\n    //                 textObject.scaleY = 1;\r\n    //                 let cos = Math.cos(textObject.angle * Math.PI / 180);\r\n    //                 let sin = Math.sin(textObject.angle * Math.PI / 180);\r\n\r\n    //                 textObject.left += textObject.width * textObject.scaleX * 0.05 * cos;\r\n    //                 textObject.top += textObject.width * textObject.scaleX * 0.05 * sin;\r\n\r\n    //                 delete textObject['text'];\r\n    //                 delete textObject['fontSize'];\r\n    //                 delete textObject['fontWeight'];\r\n    //                 delete textObject['fontFamily'];\r\n    //                 delete textObject['fontStyle'];\r\n    //                 delete textObject['lineHeight'];\r\n    //                 delete textObject['textDecoration'];\r\n    //                 delete textObject['textAlign'];\r\n    //                 delete textObject['textBackgroundColor'];\r\n    //                 delete textObject['charSpacing'];\r\n    //                 delete textObject['editable'];\r\n    //                 delete textObject['vertical'];\r\n    //                 delete textObject['styles'];\r\n\r\n    //                 textObject.pathIndex = item.pathIndex;\r\n    //                 textObject.areaEmbroider = item.areaEmbroider\r\n    //                 _formattedSide.canvas.objects[i] = textObject;\r\n    //                 _formattedSide.canvas.objects.push(item);\r\n    //             }\r\n    //         }\r\n    //         if (item.brush) item.pathIndex = -1;\r\n    //     });\r\n\r\n    //     _formattedSide.canvas.objects_print = [];\r\n    //     _formattedSide.canvas.objects_embroidery = [];\r\n    //     _formattedSide.canvas.objects_special_draw = [];\r\n    //     _formattedSide.canvas.objects.forEach((item: any, i: any) => {\r\n    //         if ((item.brush) || (item.pathIndex === -1)) {\r\n    //             _formattedSide.canvas.objects_print.push(item);\r\n    //         } else {\r\n\r\n    //             if ((item.pathIndex) && (item.pathIndex == DrawTool.modeSetup.LASER)) {\r\n    //                 _formattedSide.border = this.getBorder();\r\n    //                 item.pathBorderLaser = {\r\n    //                     size: this.size, border: _formattedSide.border.cm,\r\n    //                     center: this.center, _pan_x0: this._pan_x0, _pan_y0: this._pan_y0,\r\n    //                     borderPixel: _formattedSide.border.pixel\r\n    //                 };\r\n    //                 _formattedSide.canvas.objects_special_draw.push(item);\r\n    //             }\r\n    //             else if ((item.pathIndex) && (item.pathIndex == DrawTool.modeSetup.EMBROIDER)) {\r\n    //                 _formattedSide.canvas.objects_embroidery.push(item);\r\n    //             }\r\n    //             else {\r\n    //                 _formattedSide.canvas.objects_print.push(item);\r\n    //             }\r\n    //         }\r\n    //     });\r\n\r\n    //     if (this.backdrop) {\r\n    //         _formattedSide.imageUrl = this.imageUrl\r\n    //     }\r\n\r\n    //     if (this.FabricBorder) {\r\n    //         _formattedSide.border = this.getBorder();\r\n    //         _formattedSide.factor = {\r\n    //             x: this.getBorder().pixel.width / this.defaultWorkspaceSize.width,\r\n    //             y: this.getBorder().pixel.height / this.defaultWorkspaceSize.height,\r\n    //         }\r\n    //     }\r\n\r\n    //     _formattedSide.about = {\r\n    //         appVersion: navigator.appVersion,\r\n    //         userAgent: navigator.userAgent,\r\n    //         language: navigator.language,\r\n    //         languages: navigator.languages,\r\n    //     };\r\n    //     DrawTool._embroideryPaths.splice(4);\r\n    //     let designSide = DrawTool._designBorders.find((b: any) => b.sideId === this.id);\r\n    //     let designSideEmbroider = DrawTool._embroideryPaths.find((b: any) => b.sideId === this.id);\r\n    //     if (typeof designSide !== 'undefined') {\r\n    //         let paths = DrawTool.recs2paths(designSide.border);\r\n    //         const pathOset = 1.1;\r\n    //         var ptS = '';\r\n    //         designSideEmbroider.border.forEach((el: any) => {\r\n    //             if (el.paths && el.cm) {\r\n    //                 ptS += el.paths + ' ';\r\n    //             }\r\n    //         });\r\n    //         if ((DrawTool.modeToolDraw == DrawTool.modeSetup.EMBROIDER)) {\r\n    //             var patN: any = {\r\n    //                 paths: [ptS],\r\n    //                 cm: designSideEmbroider.bd.cm,\r\n    //                 pixel: designSideEmbroider.bd.pixel\r\n    //             };\r\n    //             if (designSideEmbroider.sideId !== '1') {\r\n    //                 delete patN.paths;\r\n    //             }\r\n    //             _formattedSide.design_border = patN;\r\n    //         }\r\n\r\n    //     }\r\n    //     return JSON.stringify(_formattedSide);\r\n    // }\r\n\r\n    getBorder() {\r\n        let paddingTop = (this.FabricCanvas.height - (this.backdrop.height * this.backdrop.scaleY)) / 2;\r\n        let paddingLeft = (this.FabricCanvas.width - (this.backdrop.width * this.backdrop.scaleX)) / 2;\r\n        let border = {\r\n            cm: {\r\n                left: (this.FabricBorder.left + this.bgOffset.left - paddingLeft) / this.cmSize.width,\r\n                top: (this.FabricBorder.top + this.bgOffset.top - paddingTop) / this.cmSize.height,\r\n                width: (this.FabricBorder.width * this.FabricBorder.scaleX) / this.cmSize.width,\r\n                height: (this.FabricBorder.height * this.FabricBorder.scaleY) / this.cmSize.height,\r\n            },\r\n            pixel: {\r\n                left: this.FabricBorder.left + this.bgOffset.left - paddingLeft,\r\n                top: this.FabricBorder.top + this.bgOffset.top - paddingTop,\r\n                width: this.FabricBorder.width * this.FabricBorder.scaleX,\r\n                height: this.FabricBorder.height * this.FabricBorder.scaleY,\r\n            }\r\n        };\r\n\r\n        if (typeof this.border.paths !== 'undefined' && this.border.paths.length > 0)\r\n            (border as any).paths = this.border.paths;\r\n\r\n        return border\r\n    }\r\n\r\n    /**\r\n *\r\n * @param options {Object} options\r\n * @param options.width {Number} Width of border\r\n * @param options.height {Number} Height of border\r\n * @param options.top {Number} Top position\r\n * @param options.left {Number} Left position\r\n */\r\n    setBorder(options: any, isReset = false) {\r\n\r\n        if (!this.cmSize) {\r\n            throw (new Error(JSON.stringify({ error: errors.sideNoSize })));\r\n            return false;\r\n        }\r\n\r\n        if (!options) {\r\n            return false;\r\n        }\r\n\r\n        if (this.FabricBorder) {\r\n            this.FabricCanvas.remove(this.FabricBorder);\r\n            this.FabricBorder.remove();\r\n        }\r\n\r\n        this.border = options;\r\n\r\n        let paddingTop = (this.FabricCanvas.height - (this.backdrop.height * this.backdrop.scaleY)) / 2;\r\n        let paddingLeft = (this.FabricCanvas.width - (this.backdrop.width * this.backdrop.scaleX)) / 2;\r\n\r\n        if (typeof options.paths === 'object') {\r\n\r\n            let pathCroup: any = [],\r\n                scaleX = 1,\r\n                scaleY = 1,\r\n                left = 0,\r\n                top = 0;\r\n\r\n            let that = this;\r\n            if (DrawTool.is_nail && options.paths.length === 1) {\r\n                let originalPath = options.paths[0];\r\n                let modifiPaths = [];\r\n                let firstPath = `\"M${options.cm.left} ${options.cm.top} h${0.01} v${0.01} h-${0.01} v-${0.01} M${options.cm.left + options.cm.width} ${options.cm.top + options.cm.height} h -${0.01} v -${0.01} h ${0.01} v ${0.01}\"`;\r\n                modifiPaths.push(firstPath);\r\n                while (true) {\r\n                    let paths = originalPath.replace(\"Z M\", \"Z,M\").split(\",\");\r\n                    modifiPaths.push(paths[0]);\r\n                    if (paths.length > 1) {\r\n                        originalPath = paths[1];\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n                options.paths = modifiPaths;\r\n            }\r\n\r\n            Array.prototype.forEach.call(options.paths, (item, i) => {\r\n                let path = new fabric.fabric.Path(item);\r\n\r\n                path.set({\r\n                    top: (path.top! - top) * scaleY,\r\n                    left: (path.left! - left) * scaleX,\r\n                    strokeWidth: DrawTool.border.strokeWidth,\r\n                    stroke: DrawTool.border.color,\r\n                    fill: i !== 0 ? 'rgba(255,255,255,0.1)' : DrawTool.border.backgroundColor,\r\n                    hasRotatingPoint: false,\r\n                    lockRotation: true,\r\n                    strokeDashArray: DrawTool.border.strokeDashArray,\r\n                    scaleX: scaleX,\r\n                    scaleY: scaleY\r\n                });\r\n\r\n                if (i === 0) {\r\n                    path.scaleToWidth(options.cm.width * this.cmSize.width);\r\n                    path.scaleToHeight(options.cm.height * this.cmSize.height);\r\n\r\n                    top = path.top!;\r\n                    left = path.left!;\r\n                    scaleX = path.scaleX!;\r\n                    scaleY = path.scaleY!;\r\n                    path.set({\r\n                        top: 0,\r\n                        left: 0\r\n                    });\r\n                }\r\n\r\n                pathCroup.push(path);\r\n            });\r\n\r\n            this.FabricBorder = new fabric.fabric.Group(pathCroup, {\r\n                width: options.cm.width * this.cmSize.width,\r\n                height: options.cm.height * this.cmSize.height,\r\n                top: options.cm.top * this.cmSize.height + paddingTop - this.bgOffset.top,\r\n                left: options.cm.left * this.cmSize.width + paddingLeft - this.bgOffset.left\r\n            });\r\n        } else {\r\n            if (!isReset) {\r\n                this.FabricBorder = new fabric.fabric.Rect({\r\n                    width: options.cm.width * this.cmSize.width,\r\n                    height: options.cm.height * this.cmSize.height,\r\n                    top: options.cm.top * this.cmSize.height + paddingTop - this.bgOffset.top,\r\n                    left: options.cm.left * this.cmSize.width + paddingLeft - this.bgOffset.left,\r\n                    strokeWidth: DrawTool.border.strokeWidth,\r\n                    stroke: DrawTool.border.color,\r\n                    fill: DrawTool.border.backgroundColor,\r\n                    hasRotatingPoint: false,\r\n                    lockRotation: true,\r\n                    strokeDashArray: DrawTool.border.strokeDashArray\r\n                });\r\n            } else {\r\n                this.FabricBorder = new fabric.fabric.Rect({\r\n                    width: options.cm.width * this.cmSize.width,\r\n                    height: options.cm.height * this.cmSize.height,\r\n                    top: options.cm.top,\r\n                    left: options.cm.left,\r\n                    strokeWidth: DrawTool.border.strokeWidth,\r\n                    stroke: DrawTool.border.color,\r\n                    fill: DrawTool.border.backgroundColor,\r\n                    hasRotatingPoint: false,\r\n                    lockRotation: true,\r\n                    strokeDashArray: DrawTool.border.strokeDashArray\r\n                });\r\n            }\r\n        }\r\n\r\n        this.FabricBorder.setCoords();\r\n        this.FabricBorder.id = 'FabricBorder';\r\n\r\n        this.FabricBorder.excludeFromExport = true;\r\n        this.FabricBorder.selectable = DrawTool.editable;\r\n        this.FabricBorder.hoverCursor = 'default';\r\n        for (var i = 0; i < this.items._collection.length; i++) {\r\n            this.items._collection[i].set({\r\n                clipTo: this.overlay ? \"\" : clip(this.FabricBorder)\r\n            });\r\n        }\r\n\r\n        this.FabricCanvas.add(this.FabricBorder);\r\n        this.center = this.FabricBorder.getCenterPoint();\r\n\r\n        this.FabricCanvas.renderAll();\r\n        return this;\r\n    }\r\n\r\n    isExistItem(item: any) {\r\n        let exist = false;\r\n\r\n        for (let i in this.layers.list) {\r\n            if (this.layers.list[i].index === item.uuid) {\r\n                exist = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return exist;\r\n    }\r\n\r\n    createCoordinates(coordinates: any) {\r\n        return {\r\n            tl: {\r\n                x: coordinates.tl.x,\r\n                y: coordinates.tl.y\r\n            },\r\n            tr: {\r\n                x: coordinates.tr.x,\r\n                y: coordinates.tr.y\r\n            },\r\n            bl: {\r\n                x: coordinates.bl.x,\r\n                y: coordinates.bl.y\r\n            },\r\n            br: {\r\n                x: coordinates.br.x,\r\n                y: coordinates.br.y\r\n            },\r\n        };\r\n    }\r\n\r\n\r\n    getOccupiedAreaSize() {\r\n        let occupiedAreaSize = {\r\n            width: 0,\r\n            height: 0\r\n        };\r\n\r\n        let maxOccupiedAreaCoordinates: any = false;\r\n\r\n        Array.prototype.forEach.call(this.items._collection, (item: any) => {\r\n            if (this.isExistItem(item) && item.intersectsWithObject(this.FabricBorder)) {\r\n                let coordinatesOccupiedArea = this.createCoordinates(item.aCoords);\r\n\r\n                if (coordinatesOccupiedArea.tl.x < this.FabricBorder.aCoords.tl.x) {\r\n                    coordinatesOccupiedArea.tl.x = this.FabricBorder.aCoords.tl.x;\r\n                    coordinatesOccupiedArea.bl.x = this.FabricBorder.aCoords.bl.x;\r\n                }\r\n\r\n                if (coordinatesOccupiedArea.tl.y < this.FabricBorder.aCoords.tl.y) {\r\n                    coordinatesOccupiedArea.tl.y = this.FabricBorder.aCoords.tl.y;\r\n                    coordinatesOccupiedArea.tr.y = this.FabricBorder.aCoords.tr.y;\r\n                }\r\n\r\n                if (coordinatesOccupiedArea.br.x > this.FabricBorder.aCoords.br.x) {\r\n                    coordinatesOccupiedArea.br.x = this.FabricBorder.aCoords.br.x;\r\n                    coordinatesOccupiedArea.tr.x = this.FabricBorder.aCoords.tr.x;\r\n                }\r\n\r\n                if (coordinatesOccupiedArea.br.y > this.FabricBorder.aCoords.br.y) {\r\n                    coordinatesOccupiedArea.br.y = this.FabricBorder.aCoords.br.y;\r\n                    coordinatesOccupiedArea.bl.y = this.FabricBorder.aCoords.bl.y;\r\n                }\r\n\r\n                if (!maxOccupiedAreaCoordinates) {\r\n                    maxOccupiedAreaCoordinates = coordinatesOccupiedArea;\r\n                } else {\r\n                    if (coordinatesOccupiedArea.tl.x < maxOccupiedAreaCoordinates.tl.x) {\r\n                        maxOccupiedAreaCoordinates.tl.x = coordinatesOccupiedArea.tl.x;\r\n                        maxOccupiedAreaCoordinates.bl.x = coordinatesOccupiedArea.tl.x;\r\n                    }\r\n\r\n                    if (coordinatesOccupiedArea.tl.y < maxOccupiedAreaCoordinates.tl.y) {\r\n                        maxOccupiedAreaCoordinates.tl.y = coordinatesOccupiedArea.tl.y;\r\n                        maxOccupiedAreaCoordinates.tr.y = coordinatesOccupiedArea.tr.y;\r\n                    }\r\n\r\n                    if (coordinatesOccupiedArea.br.x > maxOccupiedAreaCoordinates.br.x) {\r\n                        maxOccupiedAreaCoordinates.br.x = coordinatesOccupiedArea.br.x;\r\n                        maxOccupiedAreaCoordinates.tr.x = coordinatesOccupiedArea.tr.x;\r\n                    }\r\n\r\n                    if (coordinatesOccupiedArea.br.y > maxOccupiedAreaCoordinates.br.y) {\r\n                        maxOccupiedAreaCoordinates.br.y = coordinatesOccupiedArea.br.y;\r\n                        maxOccupiedAreaCoordinates.bl.y = coordinatesOccupiedArea.br.y;\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        let workAreaCenter = this.FabricBorder.getCenterPoint();\r\n\r\n        if (maxOccupiedAreaCoordinates) {\r\n            occupiedAreaSize.width = Math.max(Math.abs(workAreaCenter.x - maxOccupiedAreaCoordinates.tl.x), Math.abs(workAreaCenter.x - maxOccupiedAreaCoordinates.tr.x)) * 2;\r\n            occupiedAreaSize.height = Math.max(Math.abs(workAreaCenter.y - maxOccupiedAreaCoordinates.tl.y), Math.abs(workAreaCenter.y - maxOccupiedAreaCoordinates.bl.y)) * 2;\r\n        }\r\n\r\n        return occupiedAreaSize;\r\n    }\r\n}\r\n\r\nexport default Side","D:\\Project\\react\\demo-upt\\src\\Drawtool\\draw-tool\\Items.ts",[],"D:\\Project\\react\\demo-upt\\src\\Drawtool\\draw-tool\\Layers.ts",[],"D:\\Project\\react\\demo-upt\\src\\Drawtool\\utils\\colorPicker.ts",["156"],"import { fabric } from 'fabric';\r\nimport Side from '../draw-tool/Side';\r\n\r\nclass colorPicker {\r\n    side: any\r\n    _active: boolean\r\n    _color: any\r\n    cursor: any\r\n    constructor(side: Side) {\r\n\r\n        var that = this;\r\n\r\n        this.side = side;\r\n\r\n        this._active = false;\r\n\r\n        this._color = '#000000';\r\n\r\n        this.cursor = new fabric.Circle({\r\n            left: 0,\r\n            top: 0,\r\n            radius: 20,\r\n            strokeWidth: 3,\r\n            stroke: '#ffffff',\r\n            originX: 'center',\r\n            originY: 'center',\r\n            selectable: false,\r\n            // excludeFromExport: true,\r\n            evented: false,\r\n            // shadow: new fabric.Shadow('2px 2px 10px rgba(0,0,0,0.2)'),\r\n            lockUniScaling: true\r\n        });\r\n\r\n        return this;\r\n    }\r\n\r\n    set active(value) {\r\n        this._active = value;\r\n        if (value !== undefined && !value) {\r\n            this.side.FabricCanvas.remove(this.cursor);\r\n            this.side.items._collection.forEach((object: any) => object.selectable = !value);\r\n            this.side.FabricCanvas.hoverCursor = 'all-scroll';\r\n        } else if (value === true) {\r\n            this.side.items._collection.forEach((object: any) => object.selectable = !value);\r\n            this.side.FabricCanvas.hoverCursor = 'url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAAbFBMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB0Iv+qAAAAJHRSTlMAz7bnBNm547yTjhD+697Hw7KJfcumoJJ2XCkYCvDBVElEMiHmZ6DLAAAAiElEQVQY023ORw6EMBQDUBMI6Y3ept//jqNILEKCl0//W8Zb9yjCxGgL7kd86DNX9wJIlWEXoc114Hdatygbmpqct6WS+waHdbvchjhE117lDROFJEiVymkAmEMapSs0diYixZUCVuAwqe6+YzJ+mCXRH6/CAeCb7ZVGAY3HNfNjQ+DIsjDK9z+4kgU9DvokHAAAAABJRU5ErkJggg==\"), auto';\r\n            // this.side.items.selected.deactivate();\r\n        }\r\n    }\r\n\r\n    get active() {\r\n        return this._active;\r\n    }\r\n\r\n    set color(color) {\r\n        if (color !== undefined && color) {\r\n            this._color = color;\r\n            this.cursor.setFill(color);\r\n        }\r\n    }\r\n\r\n    get color() {\r\n        return this._color;\r\n    }\r\n\r\n    move(e: any) {\r\n        // let pointer = this.side.FabricCanvas.getPointer(e.e);\r\n\r\n        let absoluteOffset = e.e.target.getBoundingClientRect();\r\n        let coord = {\r\n            x: e.e.layerX || e.e.touches[0].clientX - absoluteOffset.left,\r\n            y: e.e.layerY || e.e.touches[0].clientY - absoluteOffset.top\r\n        };\r\n\r\n        this.color = this.getColor(coord.x * window.devicePixelRatio, coord.y * window.devicePixelRatio);\r\n\r\n        // this.side.FabricCanvas.remove(this.cursor);\r\n        // this.side.FabricCanvas.add(this.cursor);\r\n        // this.cursor.bringToFront();\r\n        //\r\n        // if(e.e.layerX < 50 || e.e.layerY < 50){\r\n        //   this.cursor.top = pointer.y + 30;\r\n        //   this.cursor.left = pointer.x + 30;\r\n        // } else {\r\n        //   this.cursor.top = pointer.y - 30;\r\n        //   this.cursor.left = pointer.x - 30;\r\n        // }\r\n        //\r\n        // this.side.FabricCanvas.renderAll()\r\n    }\r\n\r\n    getColor(x: any, y: any) {\r\n\r\n        let px = this.side.FabricCanvas.contextContainer.getImageData(x, y, 1, 1).data;\r\n\r\n        return '#' + new fabric.Color('rgb(' + px[0] + ', ' + px[1] + ', ' + px[2] + ')').toHex();\r\n    }\r\n\r\n};\r\n\r\nexport default colorPicker;\r\n","D:\\Project\\react\\demo-upt\\src\\Drawtool\\utils\\clip.ts",["157","158","159"],"export default function (border: any, offset = true) {\r\n\r\n  if (typeof border._objects !== 'undefined' && border._objects.length > 0 && border._objects[0].type === 'path') {\r\n    var generate = function () {\r\n      return `\r\n          if(!!this.lastBorder){\r\n              var dataBoder=JSON.parse(this.lastBorder);\r\n              if(dataBoder.isPath){\r\n                    var border = dataBoder.border;\r\n                    var offsetY = dataBoder.offsetY;\r\n                    var offsetX = dataBoder.offsetX;\r\n        \r\n                    this.setCoords();\r\n                    ctx.save();\r\n                    var m = this.calcTransformMatrix();\r\n                    var iM = fabric.util.invertTransform(m);\r\n                    ctx.transform.apply(ctx, iM);\r\n                    ctx.beginPath();\r\n                    for(var i=0;i<dataBoder.allBorder.length;i++){\r\n                      let path = dataBoder.allBorder[i];\r\n                      var valueX=offsetX - dataBoder.minX * border.scaleX + (dataBoder.drawToolBorder.strokeWidth / 2) * border.scaleX;\r\n                      var valueY=offsetY - dataBoder.minY * border.scaleY + (dataBoder.drawToolBorder.strokeWidth / 2) * border.scaleY;\r\n                      DrawTool.drawPathOnCtx.call(\r\n                        path,\r\n                        ctx,\r\n                        valueX,\r\n                        valueY,\r\n                        border.scaleX,\r\n                        border.scaleY\r\n                      );\r\n  \r\n                    }\r\n        \r\n                    ctx.closePath();\r\n                    ctx.restore();\r\n              }\r\n              else\r\n              {\r\n                  this.setCoords();\r\n                  var clipRect = dataBoder.border;\r\n                  var offsetY = dataBoder.offsetY;\r\n                  var offsetX = dataBoder.offsetX;\r\n                  ctx.save();\r\n                  var m = this.calcTransformMatrix();\r\n                  var iM = fabric.util.invertTransform(m);\r\n                  ctx.transform.apply(ctx, iM);\r\n                  ctx.beginPath();\r\n          \r\n                  ctx.rect(\r\n                    offsetX,\r\n                    offsetY,\r\n                    clipRect.width - clipRect.strokeWidth,\r\n                    clipRect.height - clipRect.strokeWidth\r\n                  );\r\n                  ctx.closePath();\r\n                  ctx.restore();\r\n              }\r\n          }\r\n          else\r\n          {\r\n            if((!!DrawTool.sides.selected.FabricBorder._objects)&&(DrawTool.sides.selected.FabricBorder._objects.length>0)){\r\n              var border = fabric.util.object.clone(DrawTool.sides.selected.FabricBorder._objects[0]);\r\n              var offset = ${JSON.stringify(offset)};\r\n              if(offset){\r\n                var offsetY = DrawTool.sides.selected.FabricBorder.top;\r\n                var offsetX = DrawTool.sides.selected.FabricBorder.left;\r\n              } else {\r\n                var offsetY = 0;\r\n                var offsetX = 0;\r\n              }\r\n  \r\n              this.setCoords();\r\n              ctx.save();\r\n              var m = this.calcTransformMatrix();\r\n              var iM = fabric.util.invertTransform(m);\r\n              ctx.transform.apply(ctx, iM);\r\n              ctx.beginPath();\r\n  \r\n              Array.prototype.forEach.call(DrawTool.sides.selected.FabricBorder._objects, function(path, i) {\r\n                DrawTool.drawPathOnCtx.call(\r\n                  path,\r\n                  ctx,\r\n                  offsetX - border.minX * border.scaleX + (DrawTool.border.strokeWidth / 2) * border.scaleX,\r\n                  offsetY - border.minY * border.scaleY + (DrawTool.border.strokeWidth / 2) * border.scaleY,\r\n                  border.scaleX,\r\n                  border.scaleY\r\n                );\r\n              });\r\n  \r\n              ctx.closePath();\r\n              ctx.restore();\r\n            }\r\n            else\r\n            {\r\n  \r\n              this.setCoords();\r\n                var offsetY = DrawTool.sides.selected.FabricBorder.top;\r\n                var offsetX = DrawTool.sides.selected.FabricBorder.left;\r\n                ctx.save();\r\n                var m = this.calcTransformMatrix();\r\n                var iM = fabric.util.invertTransform(m);\r\n                ctx.transform.apply(ctx, iM);\r\n                ctx.beginPath();\r\n        \r\n                ctx.rect(\r\n                  offsetX,\r\n                  offsetY,\r\n                  DrawTool.sides.selected.FabricBorder.width - DrawTool.sides.selected.FabricBorder.strokeWidth,\r\n                  DrawTool.sides.selected.FabricBorder.height - DrawTool.sides.selected.FabricBorder.strokeWidth\r\n                );\r\n                ctx.closePath();\r\n                ctx.restore();\r\n  \r\n            }\r\n          }\r\n          `;\r\n    }\r\n  } else {\r\n    var rect = Object.assign({}, {\r\n      left: border.left,\r\n      top: border.top,\r\n      width: border.width,\r\n      height: border.height,\r\n      strokeWidth: border.strokeWidth,\r\n    });\r\n\r\n    var generate = function () {\r\n      return `\r\n          if(!!this.lastBorder){\r\n            var dataBoder=JSON.parse(this.lastBorder);\r\n            if(dataBoder.isPath){\r\n                    var border = dataBoder.border;\r\n                    var offsetY = dataBoder.offsetY;\r\n                    var offsetX = dataBoder.offsetX;\r\n        \r\n                    this.setCoords();\r\n                    ctx.save();\r\n                    var m = this.calcTransformMatrix();\r\n                    var iM = fabric.util.invertTransform(m);\r\n                    ctx.transform.apply(ctx, iM);\r\n                    ctx.beginPath();\r\n                    for(var i=0;i<dataBoder.allBorder.length;i++){\r\n                      let path = dataBoder.allBorder[i];\r\n                      var valueX=offsetX - dataBoder.minX * border.scaleX + (dataBoder.drawToolBorder.strokeWidth / 2) * border.scaleX;\r\n                      var valueY=offsetY - dataBoder.minY * border.scaleY + (dataBoder.drawToolBorder.strokeWidth / 2) * border.scaleY;\r\n                      DrawTool.drawPathOnCtx.call(\r\n                        path,\r\n                        ctx,\r\n                        valueX,\r\n                        valueY,\r\n                        border.scaleX,\r\n                        border.scaleY\r\n                      );\r\n                    }\r\n        \r\n                    ctx.closePath();\r\n                    ctx.restore();\r\n            }\r\n            else\r\n            {\r\n              this.setCoords();\r\n              var clipRect = dataBoder.border;\r\n              var offsetY = dataBoder.offsetY;\r\n              var offsetX = dataBoder.offsetX;\r\n              ctx.save();\r\n              var m = this.calcTransformMatrix();\r\n              var iM = fabric.util.invertTransform(m);\r\n              ctx.transform.apply(ctx, iM);\r\n              ctx.beginPath();\r\n      \r\n              ctx.rect(\r\n                offsetX,\r\n                offsetY,\r\n                clipRect.width - clipRect.strokeWidth,\r\n                clipRect.height - clipRect.strokeWidth\r\n              );\r\n              ctx.closePath();\r\n              ctx.restore();\r\n            }\r\n          }\r\n          else\r\n          {\r\n             this.setCoords();\r\n              var clipRect = ${JSON.stringify(rect)};\r\n              var offset = ${JSON.stringify(offset)};\r\n      \r\n              if(offset){\r\n                var offsetY = clipRect.top;\r\n                var offsetX = clipRect.left;\r\n              } else {\r\n                var offsetY = 0;\r\n                var offsetX = 0;\r\n              }\r\n              ctx.save();\r\n              var m = this.calcTransformMatrix();\r\n              var iM = fabric.util.invertTransform(m);\r\n              ctx.transform.apply(ctx, iM);\r\n              ctx.beginPath();\r\n      \r\n              ctx.rect(\r\n                offsetX,\r\n                offsetY,\r\n                clipRect.width - clipRect.strokeWidth,\r\n                clipRect.height - clipRect.strokeWidth\r\n              );\r\n              ctx.closePath();\r\n              ctx.restore();\r\n          }\r\n  \r\n          `\r\n    }\r\n  }\r\n\r\n  return new Function('ctx', generate());\r\n};\r\n","D:\\Project\\react\\demo-upt\\src\\Drawtool\\draw-tool\\Item.ts",[],["160","161"],"D:\\Project\\react\\demo-upt\\src\\Drawtool\\utils\\custom-filter\\changeToCropPathProcessing.ts",["162","163"],"import { fabric } from 'fabric';\r\n\r\nlet extend = fabric.util.object.extend;\r\nlet filters = fabric.Image.filters as any;\r\nlet createClass = fabric.util.createClass;\r\n\r\nfilters.ChangeToCropPathProcessing = createClass(filters.BaseFilter, {\r\n\r\n    type: 'ChangeToCropPathProcessing',\r\n\r\n    initialize: function (options: any) {\r\n        options = options || {};\r\n\r\n        this.color = options.color || '#ffffff';\r\n\r\n        this.distance = options.distance;\r\n\r\n    },\r\n\r\n    applyTo: function (canvasEl: any) {\r\n        var context = canvasEl.getContext('2d');\r\n        //    imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n        //    data = imageData.data;\r\n        var width = canvasEl.width;\r\n        var height = canvasEl.height;\r\n        //\tvar lengPoint = Math.floor(data.length / 4);\r\n        var xt = width - 1,\r\n            yt = height - 1;\r\n        context.beginPath();\r\n        //\"M0 0 L75 200 L225 200 Z\"\r\n        var pathS = \"M\";\r\n        for (var i = 0; i < this.distance.length; i++) {\r\n            if (this.distance[i].x < 0) this.distance[i].x = 0;\r\n            else\r\n                if (this.distance[i].x > xt) this.distance[i].x = xt;\r\n\r\n            if (this.distance[i].y < 0) this.distance[i].y = 0;\r\n            else\r\n                if (this.distance[i].y > yt) this.distance[i].y = yt;\r\n            //if(i==0)  pathS = pathS+  this.distance[i].x+\" \"+ this.distance[i].y +\" \";\r\n            //else  pathS = pathS+ \"L\"+  this.distance[i].x+\" \"+ this.distance[i].y +\" \";\r\n            if (i == 0) context.moveTo(this.distance[i].x, this.distance[i].y);\r\n            else context.lineTo(this.distance[i].x, this.distance[i].y);\r\n        }\r\n        //pathS = pathS+ \"L\"+  this.distance[0].x+\" \"+ this.distance[0].y +\"Z\";\r\n        context.lineTo(this.distance[0].x, this.distance[0].y);\r\n        context.globalCompositeOperation = 'destination-in';\r\n        //let p = new Path2D(pathS);\r\n        context.closePath();\r\n        context.fill();\r\n        // reset\r\n        context.globalCompositeOperation = 'source-over';\r\n\r\n\r\n    },\r\n    toObject: function () {\r\n        return extend(this.callSuper('toObject'), {\r\n            color: this.color,\r\n            distance: this.distance,\r\n        });\r\n    }\r\n});\r\n\r\n(fabric.Image.filters as any).ChangeToCropPathProcessing.fromObject = function (object: any) {\r\n    return new (fabric.Image.filters as any).ChangeToCropPathProcessing(object);\r\n}\r\n","D:\\Project\\react\\demo-upt\\src\\Drawtool\\utils\\custom-filter\\imageChangeColorAll.ts",["164","165","166"],"import { fabric } from 'fabric';\r\n\r\nlet extend = fabric.util.object.extend;\r\nlet filters = fabric.Image.filters as any;\r\nlet createClass = fabric.util.createClass;\r\n\r\nfilters.ImageChangeColorAll = createClass(filters.BaseFilter, {\r\n\r\n    type: 'ImageChangeColorAll',\r\n    initialize: function (options: any) {\r\n        options = options || {};\r\n        this.color = options.color || '#ffffff';\r\n        this.distance = options.distance === undefined ? 1 : Number(options.distance);\r\n    },\r\n\r\n    applyTo: function (canvasEl: any) {\r\n        var context = canvasEl.getContext('2d'),\r\n            imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n            data = imageData.data,\r\n            color = new fabric.Color(this.color),\r\n            threshold = 60,\r\n            distance = this.distance,\r\n            limit = 255 - threshold,\r\n            r, g, b;\r\n        r = color.getSource()[0];\r\n        g = color.getSource()[1];\r\n        b = color.getSource()[2];\r\n        for (var i = 0, len = data.length; i < len; i += 4) {\r\n\r\n            if (data[i + 3] != 0) {\r\n                data[i] = r;\r\n                data[i + 1] = g;\r\n                data[i + 2] = b;\r\n            }\r\n        }\r\n        context.putImageData(imageData, 0, 0);\r\n    },\r\n\r\n    toObject: function () {\r\n        return extend(this.callSuper('toObject'), {\r\n            color: this.color,\r\n            distance: this.distance,\r\n        });\r\n    }\r\n});\r\n\r\n(fabric.Image.filters as any).ImageChangeColorAll.fromObject = function (object: any) {\r\n    return new (fabric.Image.filters as any).ImageChangeColorAll(object);\r\n}\r\n","D:\\Project\\react\\demo-upt\\src\\Drawtool\\utils\\custom-filter\\imageProcessingColor.ts",["167","168","169","170","171","172","173"],"import fabric from 'fabric';\r\n\r\nlet extend = fabric.fabric.util.object.extend;\r\nlet filters = fabric.fabric.Image.filters as any;\r\nlet createClass = fabric.fabric.util.createClass;\r\n\r\nfilters.ImageProcessingColor = createClass(filters.BaseFilter, {\r\n\r\n    type: 'ImageProcessingColor',\r\n    arrayImage: [],\r\n    arrayImageOutput: [],\r\n    arrayImageMash: [],\r\n    Histogram: [],\r\n    Thr: 0,\r\n    numberFillter: 0,\r\n    width: 0,\r\n    height: 0,\r\n\r\n    initialize: function (options: any) {\r\n        options = options || {};\r\n\r\n        this.color = options.color || '#ffffff';\r\n\r\n        this.distance = options.distance === undefined ? 1 : Number(options.distance);\r\n\r\n    },\r\n\r\n    applyTo: function (canvasEl: any) {\r\n        var context = canvasEl.getContext('2d'),\r\n            imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n            data = imageData.data,\r\n            color = new fabric.fabric.Color(this.color),\r\n            threshold = 60,\r\n            distance = this.distance,\r\n            limit = 255 - threshold,\r\n            r, g, b;\r\n\r\n        this.ImageProcessing(canvasEl.width, canvasEl.height, data);\r\n        var counter = 0;\r\n        for (var i = 0, len = data.length; i < len; i += 4) {\r\n            data[i] = color.getSource()[0];\r\n            data[i + 1] = color.getSource()[1];\r\n            data[i + 2] = color.getSource()[2];\r\n            data[i + 3] = this.arrayImageOutput[counter];\r\n            counter++;\r\n        }\r\n        context.putImageData(imageData, 0, 0);\r\n    },\r\n    ImageProcessing(width: any, height: any, imageData: any) {\r\n        this.width = width;\r\n        this.height = height;\r\n        this.arrayImage = new Uint8Array(width * height);\r\n        this.Histogram = new Uint32Array(256);\r\n        this.arrayImageMash = new Uint8Array(width * height);\r\n        var location = 0;\r\n        var locationImage = 0;\r\n        this.numberFillter = 0;\r\n        // gray image\r\n        for (var Y = 0; Y < height; Y++) {\r\n            location = width * Y;\r\n            locationImage = width * Y * 4;\r\n            for (var X = 0; X < width; X++) {\r\n                this.arrayImage[location] = (imageData[locationImage] + (imageData[locationImage + 1] << 1) + imageData[locationImage + 2]) >> 2;\r\n                location++;\r\n                locationImage += 4;\r\n            }\r\n        }\r\n        this.GetHistGram();\r\n        this.Thr = this.GetMinimumThreshold();\r\n        if (this.CheckHistogram() > 2) {\r\n            this.DoBinarizationMash();\r\n            this.DoBinarization(this.Thr);\r\n        }\r\n        else {\r\n            this.ProcessFilter()\r\n        }\r\n\r\n    },\r\n    GetHistGram() {\r\n        var location = 0;\r\n        for (var Y = 0; Y < 256; Y++) this.Histogram[Y] = 0;\r\n        for (var Y = 0; Y < this.height; Y++) {\r\n            location = this.width * Y;\r\n            for (var X = 0; X < this.width; X++) {\r\n                this.Histogram[this.arrayImage[location]]++;\r\n                location++;\r\n            }\r\n        }\r\n    },\r\n    CheckHistogram() {\r\n        var Y = 0, Iter = 0, IterLow = 0;\r\n        var J = 0;\r\n        for (Y = 0; Y < 256; Y++) {\r\n            if (this.Histogram[Y] > Iter) Iter = this.Histogram[Y];\r\n            for (J = 0; J < Y; J++) {\r\n                if ((this.Histogram[J] > IterLow) && (this.Histogram[J] < Iter)) IterLow = this.Histogram[J];\r\n            }\r\n        }\r\n        var scaleHistogram = Iter / IterLow;\r\n        return scaleHistogram;\r\n    },\r\n    GetMinimumThreshold() {\r\n        var Y = 0, Iter = 0;\r\n        var numberData = 0;\r\n\r\n        for (Y = 0; Y < 256; Y++) {\r\n            Iter = Iter + Y * this.Histogram[Y];\r\n            numberData = numberData + this.Histogram[Y];\r\n        }\r\n        Iter = (Iter) / numberData / 2;\r\n\r\n        return Iter;\r\n    },\r\n    DoBinarization(Threshold: any) {\r\n        if (Threshold == -1) {\r\n            //arrayImage  arrayImageOutput\r\n            return Threshold;\r\n        }\r\n        var Width = this.width - 1, Height = this.height - 1;\r\n        var loaction = 0;\r\n        var diffValue = 0;\r\n        var diffValueMash = 0;\r\n        for (var Y = 0; Y < Height; Y++) {\r\n            loaction = Y * this.width;\r\n            for (var X = 1; X < Width; X++) {\r\n                if (this.arrayImage[loaction] < Threshold) {\r\n                    diffValue = 255;\r\n                }\r\n                else\r\n                    diffValue = 0;\r\n                diffValueMash = this.arrayImageMash[loaction];\r\n                this.arrayImageOutput[loaction] = (diffValue & diffValueMash);\r\n                loaction++;\r\n            }\r\n        }\r\n    },\r\n    DoBinarizationMash() {\r\n        var Width = this.width - 1, Height = this.height - 1;\r\n        var loaction = 0;\r\n        var locationup = 0;\r\n        var locationdown = 0;\r\n        var difValue = 0;\r\n        var caculator = 0;\r\n        for (var Y = 1; Y < Height; Y++) {\r\n            loaction = Y * this.width + 1;\r\n            locationup = loaction - this.width;\r\n            locationdown = loaction + this.width;\r\n            for (var X = 1; X < Width; X++) {\r\n                caculator = Math.abs(4 * this.arrayImage[loaction] - this.arrayImage[loaction + 1]\r\n                    - this.arrayImage[loaction - 1] - this.arrayImage[locationup]\r\n                    - this.arrayImage[locationdown]);\r\n\r\n                if (caculator > 0) {\r\n                    difValue = 255;\r\n                }\r\n                else\r\n                    difValue = 0;\r\n                this.arrayImageMash[loaction] = difValue;\r\n                //arrayImageOutput[loaction] = (byte)difValue;\r\n                loaction++;\r\n                locationup = loaction - this.width;\r\n                locationdown = loaction + this.width;\r\n            }\r\n        }\r\n    },\r\n    ProcessFilter() {\r\n        // processing start and stop X,Y positions\r\n        var startX = 1;\r\n        var startY = 1;\r\n        var stopX = this.width - 1;\r\n        var stopY = this.height - 1;\r\n        var g, max = 0;\r\n        var loaction = 0;\r\n        var locationup = 0;\r\n        var locationdown = 0;\r\n        // for each line\r\n        for (var y = startY; y < stopY; y++) {\r\n            // for each pixel\r\n\r\n            loaction = y * this.width + 1;\r\n            locationup = loaction - this.width;\r\n            locationdown = loaction + this.width;\r\n            for (var x = startX; x < stopX; x++) {\r\n                g = Math.min(255,\r\n                    Math.abs(this.arrayImage[locationup - 1] + this.arrayImage[locationup + 1]\r\n                        - this.arrayImage[locationdown - 1] - this.arrayImage[locationdown + 1]\r\n                        + 2 * (this.arrayImage[locationup] - this.arrayImage[locationdown]))\r\n                    + Math.abs(this.arrayImage[locationup + 1] + this.arrayImage[locationdown + 1]\r\n                        - this.arrayImage[locationup - 1] - this.arrayImage[locationdown - 1]\r\n                        + 2 * (this.arrayImage[loaction] - this.arrayImage[loaction - 1])));\r\n\r\n                if (g > max) max = g;\r\n                this.arrayImageOutput[loaction] = g % 256;\r\n                loaction++;\r\n                locationup = loaction - this.width;\r\n                locationdown = loaction + this.width;\r\n            }\r\n        }\r\n    },\r\n\r\n    toObject: function () {\r\n        return extend(this.callSuper('toObject'), {\r\n            color: this.color,\r\n            distance: this.distance,\r\n        });\r\n    }\r\n});\r\n\r\n(fabric.fabric.Image.filters as any).ImageProcessingColor.fromObject = function (object: any) {\r\n    return new (fabric.fabric.Image.filters as any).ImageProcessingColor(object);\r\n}\r\n","D:\\Project\\react\\demo-upt\\src\\Drawtool\\utils\\custom-filter\\removeColor.ts",["174"],"import fabric from 'fabric';\r\n\r\nlet extend = fabric.fabric.util.object.extend;\r\nlet filters = fabric.fabric.Image.filters as any;\r\nlet createClass = fabric.fabric.util.createClass;\r\n\r\nfilters.RemoveColor = createClass(filters.BaseFilter, {\r\n\r\n    type: 'RemoveColor',\r\n\r\n    initialize: function (options: any) {\r\n        options = options || {};\r\n\r\n        this.color = options.color || '#ffffff';\r\n\r\n        this.distance = options.distance === undefined ? 1 : Number(options.distance);\r\n\r\n    },\r\n\r\n    applyTo: function (canvasEl: any) {\r\n        var context = canvasEl.getContext('2d'),\r\n            imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n            data = imageData.data,\r\n            color = new fabric.fabric.Color(this.color),\r\n            threshold = 60,\r\n            distance = this.distance,\r\n            limit = 255 - threshold,\r\n            r, g, b;\r\n\r\n        for (var i = 0, len = data.length; i < len; i += 4) {\r\n            r = data[i];\r\n            g = data[i + 1];\r\n            b = data[i + 2];\r\n\r\n            if (\r\n                // Math.abs(r - color.getSource ._source[0]) < distance &&\r\n                // Math.abs(g - color._source[1]) < distance &&\r\n                // Math.abs(b - color._source[2]) < distance\r\n                Math.abs(r - color.getSource()[0]) < distance &&\r\n                Math.abs(g - color.getSource()[1]) < distance &&\r\n                Math.abs(b - color.getSource()[2]) < distance\r\n            ) {\r\n                data[i + 3] = 0;\r\n            }\r\n        }\r\n        context.putImageData(imageData, 0, 0);\r\n    },\r\n\r\n    toObject: function () {\r\n        return extend(this.callSuper('toObject'), {\r\n            color: this.color,\r\n            distance: this.distance,\r\n        });\r\n    }\r\n});\r\n\r\n(fabric.fabric.Image.filters as any).RemoveColor.fromObject = function (object: any) {\r\n    return new (fabric.fabric.Image.filters as any).RemoveColor(object);\r\n}\r\n",{"ruleId":"175","replacedBy":"176"},{"ruleId":"177","replacedBy":"178"},{"ruleId":"179","severity":1,"message":"180","line":5,"column":31,"nodeType":"181","messageId":"182","endLine":5,"endColumn":48},{"ruleId":"183","severity":1,"message":"184","line":45,"column":38,"nodeType":"185","messageId":"186","endLine":45,"endColumn":40},{"ruleId":"187","severity":1,"message":"188","line":49,"column":34,"nodeType":"189","messageId":"190","endLine":57,"endColumn":10},{"ruleId":"183","severity":1,"message":"184","line":50,"column":31,"nodeType":"185","messageId":"186","endLine":50,"endColumn":33},{"ruleId":"183","severity":1,"message":"191","line":64,"column":75,"nodeType":"185","messageId":"186","endLine":64,"endColumn":77},{"ruleId":"183","severity":1,"message":"191","line":65,"column":87,"nodeType":"185","messageId":"186","endLine":65,"endColumn":89},{"ruleId":"183","severity":1,"message":"184","line":84,"column":32,"nodeType":"185","messageId":"186","endLine":84,"endColumn":34},{"ruleId":"179","severity":1,"message":"192","line":85,"column":15,"nodeType":"181","messageId":"182","endLine":85,"endColumn":30},{"ruleId":"193","severity":1,"message":"194","line":91,"column":18,"nodeType":"181","messageId":"195","endLine":91,"endColumn":19},{"ruleId":"183","severity":1,"message":"191","line":97,"column":51,"nodeType":"185","messageId":"186","endLine":97,"endColumn":53},{"ruleId":"193","severity":1,"message":"194","line":107,"column":22,"nodeType":"181","messageId":"195","endLine":107,"endColumn":23},{"ruleId":"183","severity":1,"message":"184","line":108,"column":89,"nodeType":"185","messageId":"186","endLine":108,"endColumn":91},{"ruleId":"183","severity":1,"message":"184","line":114,"column":37,"nodeType":"185","messageId":"186","endLine":114,"endColumn":39},{"ruleId":"193","severity":1,"message":"194","line":116,"column":24,"nodeType":"181","messageId":"195","endLine":116,"endColumn":25},{"ruleId":"183","severity":1,"message":"184","line":117,"column":91,"nodeType":"185","messageId":"186","endLine":117,"endColumn":93},{"ruleId":"193","severity":1,"message":"194","line":124,"column":20,"nodeType":"181","messageId":"195","endLine":124,"endColumn":21},{"ruleId":"193","severity":1,"message":"194","line":129,"column":18,"nodeType":"181","messageId":"195","endLine":129,"endColumn":19},{"ruleId":"183","severity":1,"message":"184","line":130,"column":51,"nodeType":"185","messageId":"186","endLine":130,"endColumn":53},{"ruleId":"193","severity":1,"message":"194","line":138,"column":18,"nodeType":"181","messageId":"195","endLine":138,"endColumn":19},{"ruleId":"183","severity":1,"message":"184","line":139,"column":57,"nodeType":"185","messageId":"186","endLine":139,"endColumn":59},{"ruleId":"183","severity":1,"message":"184","line":152,"column":67,"nodeType":"185","messageId":"186","endLine":152,"endColumn":69},{"ruleId":"183","severity":1,"message":"184","line":157,"column":37,"nodeType":"185","messageId":"186","endLine":157,"endColumn":39},{"ruleId":"183","severity":1,"message":"184","line":163,"column":39,"nodeType":"185","messageId":"186","endLine":163,"endColumn":41},{"ruleId":"196","severity":1,"message":"197","line":228,"column":53,"nodeType":"198","messageId":"199","endLine":228,"endColumn":55},{"ruleId":"179","severity":1,"message":"200","line":234,"column":11,"nodeType":"181","messageId":"182","endLine":234,"endColumn":26},{"ruleId":"196","severity":1,"message":"201","line":257,"column":81,"nodeType":"198","messageId":"202","endLine":257,"endColumn":83},{"ruleId":"183","severity":1,"message":"191","line":258,"column":33,"nodeType":"185","messageId":"186","endLine":258,"endColumn":35},{"ruleId":"196","severity":1,"message":"201","line":274,"column":83,"nodeType":"198","messageId":"202","endLine":274,"endColumn":85},{"ruleId":"183","severity":1,"message":"191","line":275,"column":35,"nodeType":"185","messageId":"186","endLine":275,"endColumn":37},{"ruleId":"183","severity":1,"message":"184","line":302,"column":40,"nodeType":"185","messageId":"186","endLine":302,"endColumn":42},{"ruleId":"183","severity":1,"message":"184","line":312,"column":50,"nodeType":"185","messageId":"186","endLine":312,"endColumn":52},{"ruleId":"183","severity":1,"message":"184","line":317,"column":39,"nodeType":"185","messageId":"186","endLine":317,"endColumn":41},{"ruleId":"183","severity":1,"message":"184","line":329,"column":43,"nodeType":"185","messageId":"186","endLine":329,"endColumn":45},{"ruleId":"179","severity":1,"message":"203","line":412,"column":7,"nodeType":"181","messageId":"182","endLine":412,"endColumn":20},{"ruleId":"196","severity":1,"message":"197","line":412,"column":51,"nodeType":"198","messageId":"199","endLine":412,"endColumn":53},{"ruleId":"204","severity":1,"message":"205","line":23,"column":57,"nodeType":"206","endLine":23,"endColumn":67},{"ruleId":"196","severity":1,"message":"201","line":102,"column":43,"nodeType":"198","messageId":"202","endLine":102,"endColumn":45},{"ruleId":"196","severity":1,"message":"201","line":114,"column":27,"nodeType":"198","messageId":"202","endLine":114,"endColumn":29},{"ruleId":"179","severity":1,"message":"207","line":8,"column":8,"nodeType":"181","messageId":"182","endLine":8,"endColumn":12},{"ruleId":"196","severity":1,"message":"201","line":145,"column":43,"nodeType":"198","messageId":"202","endLine":145,"endColumn":45},{"ruleId":"193","severity":1,"message":"194","line":192,"column":18,"nodeType":"181","messageId":"195","endLine":192,"endColumn":19},{"ruleId":"183","severity":1,"message":"184","line":268,"column":57,"nodeType":"185","messageId":"186","endLine":268,"endColumn":59},{"ruleId":"183","severity":1,"message":"184","line":277,"column":62,"nodeType":"185","messageId":"186","endLine":277,"endColumn":64},{"ruleId":"179","severity":1,"message":"208","line":308,"column":17,"nodeType":"181","messageId":"182","endLine":308,"endColumn":22},{"ruleId":"179","severity":1,"message":"209","line":309,"column":19,"nodeType":"181","messageId":"182","endLine":309,"endColumn":27},{"ruleId":"183","severity":1,"message":"184","line":316,"column":40,"nodeType":"185","messageId":"186","endLine":316,"endColumn":42},{"ruleId":"179","severity":1,"message":"210","line":356,"column":17,"nodeType":"181","messageId":"182","endLine":356,"endColumn":33},{"ruleId":"183","severity":1,"message":"191","line":384,"column":34,"nodeType":"185","messageId":"186","endLine":384,"endColumn":36},{"ruleId":"211","severity":1,"message":"212","line":473,"column":13,"nodeType":"213","messageId":"214","endLine":473,"endColumn":26},{"ruleId":"179","severity":1,"message":"215","line":488,"column":13,"nodeType":"181","messageId":"182","endLine":488,"endColumn":18},{"ruleId":"179","severity":1,"message":"216","line":489,"column":13,"nodeType":"181","messageId":"182","endLine":489,"endColumn":18},{"ruleId":"211","severity":1,"message":"212","line":520,"column":13,"nodeType":"213","messageId":"214","endLine":520,"endColumn":26},{"ruleId":"196","severity":1,"message":"201","line":768,"column":76,"nodeType":"198","messageId":"202","endLine":768,"endColumn":78},{"ruleId":"179","severity":1,"message":"217","line":909,"column":25,"nodeType":"181","messageId":"182","endLine":909,"endColumn":26},{"ruleId":"211","severity":1,"message":"212","line":968,"column":13,"nodeType":"213","messageId":"214","endLine":968,"endColumn":26},{"ruleId":"211","severity":1,"message":"212","line":1020,"column":13,"nodeType":"213","messageId":"214","endLine":1020,"endColumn":26},{"ruleId":"179","severity":1,"message":"210","line":1168,"column":17,"nodeType":"181","messageId":"182","endLine":1168,"endColumn":33},{"ruleId":"183","severity":1,"message":"184","line":1290,"column":40,"nodeType":"185","messageId":"186","endLine":1290,"endColumn":42},{"ruleId":"183","severity":1,"message":"184","line":1290,"column":100,"nodeType":"185","messageId":"186","endLine":1290,"endColumn":102},{"ruleId":"183","severity":1,"message":"184","line":1308,"column":54,"nodeType":"185","messageId":"186","endLine":1308,"endColumn":56},{"ruleId":"179","severity":1,"message":"218","line":1321,"column":33,"nodeType":"181","messageId":"182","endLine":1321,"endColumn":47},{"ruleId":"179","severity":1,"message":"219","line":1325,"column":37,"nodeType":"181","messageId":"182","endLine":1325,"endColumn":53},{"ruleId":"211","severity":1,"message":"212","line":1702,"column":13,"nodeType":"213","messageId":"214","endLine":1702,"endColumn":26},{"ruleId":"179","severity":1,"message":"220","line":1727,"column":17,"nodeType":"181","messageId":"182","endLine":1727,"endColumn":21},{"ruleId":"179","severity":1,"message":"220","line":11,"column":13,"nodeType":"181","messageId":"182","endLine":11,"endColumn":17},{"ruleId":"221","severity":1,"message":"222","line":1,"column":1,"nodeType":"223","endLine":215,"endColumn":2},{"ruleId":"193","severity":1,"message":"224","line":127,"column":9,"nodeType":"181","messageId":"195","endLine":127,"endColumn":17},{"ruleId":"225","severity":1,"message":"226","line":214,"column":10,"nodeType":"227","messageId":"228","endLine":214,"endColumn":41},{"ruleId":"175","replacedBy":"229"},{"ruleId":"177","replacedBy":"230"},{"ruleId":"179","severity":1,"message":"231","line":31,"column":13,"nodeType":"181","messageId":"182","endLine":31,"endColumn":18},{"ruleId":"183","severity":1,"message":"184","line":42,"column":19,"nodeType":"185","messageId":"186","endLine":42,"endColumn":21},{"ruleId":"179","severity":1,"message":"232","line":22,"column":13,"nodeType":"181","messageId":"182","endLine":22,"endColumn":21},{"ruleId":"179","severity":1,"message":"233","line":23,"column":13,"nodeType":"181","messageId":"182","endLine":23,"endColumn":18},{"ruleId":"183","severity":1,"message":"191","line":30,"column":29,"nodeType":"185","messageId":"186","endLine":30,"endColumn":31},{"ruleId":"179","severity":1,"message":"232","line":34,"column":13,"nodeType":"181","messageId":"182","endLine":34,"endColumn":21},{"ruleId":"179","severity":1,"message":"233","line":35,"column":13,"nodeType":"181","messageId":"182","endLine":35,"endColumn":18},{"ruleId":"179","severity":1,"message":"234","line":36,"column":13,"nodeType":"181","messageId":"182","endLine":36,"endColumn":14},{"ruleId":"179","severity":1,"message":"235","line":36,"column":16,"nodeType":"181","messageId":"182","endLine":36,"endColumn":17},{"ruleId":"179","severity":1,"message":"236","line":36,"column":19,"nodeType":"181","messageId":"182","endLine":36,"endColumn":20},{"ruleId":"193","severity":1,"message":"237","line":82,"column":18,"nodeType":"181","messageId":"195","endLine":82,"endColumn":19},{"ruleId":"183","severity":1,"message":"184","line":115,"column":23,"nodeType":"185","messageId":"186","endLine":115,"endColumn":25},{"ruleId":"179","severity":1,"message":"233","line":27,"column":13,"nodeType":"181","messageId":"182","endLine":27,"endColumn":18},"no-native-reassign",["238"],"no-negated-in-lhs",["239"],"@typescript-eslint/no-unused-vars","'stickerCategories' is defined but never used.","Identifier","unusedVar","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'sizePayload'.","FunctionExpression","unsafeRefs","Expected '!==' and instead saw '!='.","'dataActionValue' is assigned a value but never used.","@typescript-eslint/no-redeclare","'i' is already defined.","redeclared","array-callback-return","Array.prototype.map() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","'currentCategory' is assigned a value but never used.","Array.prototype.map() expects a return value from arrow function.","expectedInside","'overlayImages' is assigned a value but never used.","react/no-direct-mutation-state","Do not mutate state directly. Use setState().","MemberExpression","'Item' is defined but never used.","'paths' is assigned a value but never used.","'pathOset' is assigned a value but never used.","'proportionsOnOld' is assigned a value but never used.","no-unreachable","Unreachable code.","ReturnStatement","unreachableCode","'stepX' is assigned a value but never used.","'stepY' is assigned a value but never used.","'s' is assigned a value but never used.","'countItemColor' is assigned a value but never used.","'enableSelectPath' is assigned a value but never used.","'that' is assigned a value but never used.","import/no-anonymous-default-export","Unexpected default export of anonymous function","ExportDefaultDeclaration","'generate' is already defined.","no-new-func","The Function constructor is eval.","NewExpression","noFunctionConstructor",["238"],["239"],"'pathS' is assigned a value but never used.","'distance' is assigned a value but never used.","'limit' is assigned a value but never used.","'r' is defined but never used.","'g' is defined but never used.","'b' is defined but never used.","'Y' is already defined.","no-global-assign","no-unsafe-negation"]